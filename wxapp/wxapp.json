{"title": "使用gulp构建微信小程序开发工作流 ", "author": "Rolan", "time": "2020-3-25 00:36", "content": "web开发基本上都是基于webpack或者其他的构建工具来进行开发，大大节约了开发者的时间。目前的微信小程序开发也有很多开源的框架可供选择，但是如果使用原生开发模式，虽然可以完美使用小程序原生的新特性和功能，但是工作流角度上却十分简陋。19年末的时候公司要开发一个新的小程序，组里面的大佬同事提议使用gulp来构建下原生开发模式的工作流。一是为了摆脱简陋的工作流模式以节约开发时间，二是也是把技术用到刀刃上。在大佬的指导开发下，这个工作便进行了。总体来说这个工作并不难，增益可能也没有那么大，但是还是收获了很多。项目地址： gulp-mp工作流改进我们把开发目录设置在 src ，输出目录设置在 dist ，定义开发与输出路径。文件复制微信小程序的page目录通常包含 wxml , json , wxss 和 js 文件，与原生开发模式不同的是我们使用 sass 预处理器来写样式，其他的文件保持原样不同。因此，对于 wxml , json , js 文件来说，仅仅需要copy就行。因为在项目中已经配置了 eslint+prettier 来进行语法检查和代码美化，因此不需要在工作流的js代码进行规范检查。如果没有配置，可以安装 gulp-eslint 执行eslint规范检查。const srcPath = \"./src/**\";\r\nconst distPath = \"./dist/\";\r\nconst wxmlFiles = [`${srcPath}/*.wxml`];\r\nconst jsFiles = [`${srcPath}/*.js`, `!${srcPath}/env/*.js`];\r\nconst jsonFiles = [`${srcPath}/*.json`];\r\n\r\n// copy wxml\r\nconst wxml = () => {\r\n  return gulp\r\n    .src(wxmlFiles, { since: gulp.lastRun(wxml) })\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxml);\r\n\r\n// 其他copy流类似\r\n...\r\n复制代码sass处理上面我们提到使用 sass 预处理来编写样式，在输出的时候我们需要把 scss 样式转换成 wxss， wxss 就是普通的 css 样式。这里，我们使用 gulp-sass 插件转换scss样式。但是，需要注意的是在 scss 文件中，我们可能会import相关样式，可能是公共样式也可能是varibale和minxin。经过测试发现，当import公共样式，会把这个公共样式打包进当前页面。我们知道小程序的包是有大小限制的，如果在引入公共样式的时候还打包到当前页面，无疑是消耗掉了不必要的内存。所以，针对公共样式的import处理为，不交给sass处理，保留import并把后缀的.scss改成.wxss。当import的是变量和mixin时，我们需要保留对其的sass处理，因此新建独立的目录存放以便识别。在这一场景下，变量和mixin的文件不再递归处理。//存放variable和mixin的sass文件在被引用时直接导入，不引入dist目录中\r\nconst DIRECTIMPORT = [\"/scss/\", \"/font/\"];\r\nconst sassFiles = [`${srcPath}/*.{scss, wxss}`];\r\n\r\nconst wxss = () => {\r\n  return gulp\r\n    .src([...sassFiles, ...DIRECTIMPORT.map(item => `!${srcPath}/${item}/*`)], {\r\n      since: gulp.lastRun(wxss)\r\n    })\r\n    .pipe(plumber({ errorHandler: onError }))\r\n    .pipe(\r\n      tap(file => {\r\n        const filePath = path.dirname(file.path);\r\n        //console.log(\"filepath\", filePath);\r\n        file.contents = new Buffer(\r\n            // 匹配@import\r\n          String(file.contents).replace(\r\n            /@import\\s+['|\"](.+)['|\"];/g,\r\n            ($1, $2) => {\r\n              console.log(\"$1\", $1);\r\n              console.log(\"$2\", $2);\r\n              //如果不是变量或者mixin则注释掉\r\n              return DIRECTIMPORT.some(item => {\r\n                return $2.indexOf(item) > -1;\r\n              })\r\n                ? $1\r\n                : `/** ${$1} **/`;\r\n            }\r\n          )\r\n        );\r\n      })\r\n    )\r\n    .pipe(sass())\r\n    .pipe(postcss([autoprefixer([\"iOS >= 8\", \"Android >= 4.1\"])]))\r\n    .pipe(\r\n      replace(/(\\/\\*\\*\\s{0,})(@.+)(\\s{0,}\\*\\*\\/)/g, ($1, $2, $3) => {\r\n        //console.log(\"$1\", $1);\r\n        //console.log(\"$2\", $2);\r\n        //console.log(\"$3\", $3);\r\n        //去掉注释并修改scss后缀为wxss\r\n        return $3.replace(/\\.scss/g, \".wxss\");\r\n      })\r\n    )\r\n    .pipe(rename({ extname: \".wxss\" }))\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxss);\r\n复制代码压缩图片文件安装gulp-imagemin插件压缩图片。之前通过npm安装在使用的时候这个插件总是报错，后来发现是没有正确安装，瞎倒腾切换到cnpm或者yarn发现可以安装成功了。const imageFiles = [\r\n  `${srcPath}/images/*.{png,jpg,gif,ico}`,\r\n  `${srcPath}/images/**/*.{png,jpg,gif,ico}`\r\n];\r\nconst img = () => {\r\n  return gulp\r\n    .src(imageFiles, { since: gulp.lastRun(img) })\r\n    .pipe(imagemin())\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(img);\r\n复制代码区分开发环境正常开发过程中，开发，测试和发布环境通常会有不同的API接口和其他设置。在每次切换的时候手动去更改内部代码是一件很麻烦的事情，也容易遗忘，根据不同的命令自动加载相应的开发环境设置才是我们想要的效果。 在 src/env/* 目录下，配置了三个环境的变量： dev.js ， test.js ， prod.js 。const envJs = env => {\r\n  return () => {\r\n    return gulp\r\n      .src(`./src/env/${env}.js`)\r\n      .pipe(rename(\"env.js\"))\r\n      .pipe(gulp.dest(distPath));\r\n  };\r\n};\r\ngulp.task(envJs);\r\n复制代码清除dist目录在重新编译的时候我们都需要清除dist目录的资源，以免导致混乱/* 清除dist目录 */\r\ngulp.task(\"clean\", done => {\r\n  del.sync([\"dist/**\"]);\r\n  done();\r\n});\r\n复制代码自动创建目录使用命令新建page目录和component目录，只要把模版文件拷贝并重命名即可。const newfile = done => {\r\n  yargs\r\n    .example(\"gulp newfile  -p mypage\", \"创建mypage的page目录\")\r\n    .example(\"gulp newfile  -c mycomponent\", \"创建mycomponent的component目录\")\r\n    .example(\r\n      \"gulp newfile  -s srcfile -p mypage\",\r\n      \"以srcfile为模版创建mypage的page目录\"\r\n    )\r\n    .option({\r\n      s: {\r\n        alias: \"src\",\r\n        describe: \"模板\",\r\n        type: \"string\",\r\n        default: \"template\"\r\n      },\r\n      p: {\r\n        alias: \"page\",\r\n        describe: \"page名称\",\r\n        type: \"string\"\r\n      },\r\n      c: {\r\n        alias: \"component\",\r\n        describe: \"component名称\",\r\n        type: \"string\"\r\n      }\r\n    })\r\n    .fail(msg => {\r\n      done();\r\n      console.error(\"创建失败\");\r\n      console.log(msg);\r\n      console.log(\"help\");\r\n      yargs.parse([\"--msg\"]);\r\n    })\r\n    .help(\"msg\");\r\n\r\n  const args = yargs.argv;\r\n  //console.log(\"args\", args);\r\n  const source = args.s;\r\n  const filePaths = {\r\n    p: \"pages\",\r\n    c: \"components\"\r\n  };\r\n\r\n  let name,\r\n    type,\r\n    hasParam = false;\r\n  for (let key in filePaths) {\r\n    if (args[key]) {\r\n      hasParam = true;\r\n      name = args[key];\r\n      type = filePaths[key];\r\n    }\r\n  }\r\n  if (!hasParam) {\r\n    done();\r\n    yargs.parse([\"--msg\"]);\r\n  }\r\n  const defaultPath =\r\n    source === \"template\"\r\n      ? `src/${source}/${type}/*`\r\n      : `src/${type}/${source}/*`;\r\n  return gulp.src(defaultPath).pipe(gulp.dest(`src/${type}/${name}/`));\r\n};\r\ngulp.task(newfile);\r\n复制代码"}
{"title": "京喜小程序的高性能打造之路 ", "author": "Rolan", "time": "2020-3-27 00:26", "content": "本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关：其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为：FCP：白屏加载结束；FMP：首屏渲染完成；TTI：所有内容加载完成；综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现 、 setData 数据量 、 元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）：首屏时间不超过 5 秒；渲染时间不超过 500ms；每秒调用 setData 的次数不超过 20 次；setData 的数据在 JSON.stringify 后不超过 256kb；页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个；所有网络请求都在 1 秒内返回结果；详见 小程序性能评分规则我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求：setData\r\n体验评分工具小程序提供了 体验评分工具（ Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。以上截图均来自小程序官方文档体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧， 小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能 、 运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad 、 onReady 、 数据加载完成 、 首屏渲染完成 、 各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。另外，微信为开发者提供了 测速系统 ，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了 双线程模型 ：视图层 ：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；逻辑层 ：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；上图来自小程序官方开发指南然而， 任何线程间的数据传输都是有延时的 ，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。作为小程序开发者，我们常常会被下面几个问题所困扰：小程序启动慢；白屏时间长；页面渲染慢；运行内存不足；接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作：1. 准备运行环境：在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。2. 下载小程序代码包：在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。3. 加载小程序代码包：小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。4. 初始化小程序首页：在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小 ，缩小代码包的下载时间。无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。文件依赖分析在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。WXML 中的 import 和 include ：<!-- A.wxml -->\r\n<template name='A'>\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- B.wxml -->\r\n<import src=\"A.wxml\"/>\r\n<template is=\"A\" data=\"{{text: 'B'}}\"/><!-- A.wxml -->\r\n<text> A </text>\r\n\r\n<!-- B.wxml -->\r\n<include src=\"A.wxml\"/>\r\n<text> B </text>WXSS 中的 @import ：@import './A.wxss'JS 中的 require / import ：const A = require('./A')所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。JS、CSS Tree-ShakingJS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享： 小程序工程化探索 。减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG 、 PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。需要注意， Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了...（开个玩笑）通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。总结得出， 一般不涉及前端计算的展示类逻辑，都可以适当做后移 。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的：// 检查每种弹窗类型是否已展示\r\nPromise.all([\r\n  check(popup_1),\r\n  check(popup_2),\r\n  // ...\r\n  check(popup_n)\r\n]).then(result => {\r\n  // 优先级排序\r\n  const queue = [{\r\n    show: result.popup_1\r\n    data: data.popup_1\r\n  }, {\r\n    show: result.popup_2\r\n    data: data.popup_2\r\n  }, \r\n  // ...\r\n  {\r\n    show: result.popup_n\r\n    data: data.popup_n\r\n  }]\r\n})逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样：this.setData({\r\n  popup: data.popup\r\n})复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具， 我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素） 。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～当然，要完成这样的插件化改造免不了几个先决条件：用户体验设计的统一 。如果设计风格总是天差地别的，强行插件化只会成为累赘。服务端接口的统一 。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。下面为大家提供部分例程来辅助理解。其中， use 方法会接受各类处理钩子最终拼接出一个 Function ，在对应模块处理数据时会被调用。// bi.helper.js\r\n\r\n/**\r\n * 插件引擎\r\n * @param {function} options.formatName 标题处理钩子\r\n * @param {function} options.validList 数据校验器钩子\r\n */ \r\nconst use = options => data => format(data)\r\n\r\n/**\r\n * 预置插件库\r\n */ \r\nnameHelpers = {\r\n  text: data => data.text,\r\n  icon: data => data.icon\r\n}\r\nlistHelpers = {\r\n  single: list => list.slice(0, 1),\r\n  double: list => list.slice(0, 2)\r\n}\r\n\r\n/**\r\n * “堆积木”\r\n */\r\nexport default {\r\n  1000: use({\r\n    formatName: nameHelpers.text,\r\n    validList: listHelpers.single\r\n  }),\r\n\r\n  1001: use({\r\n    formatName: nameHelpers.icon,\r\n    validList: listHelpers.double\r\n  })\r\n}<!-- bi.wxml -->\r\n<!-- 各模板节点实现 -->\r\n<template name=\"renderName\">\r\n  <view wx:if=\"{{type === 'text'}}\"> text </view>\r\n  <view wx:elif=\"{{type === 'icon'}}\"> icon </view>\r\n</template>\r\n\r\n<view class=\"bi__name\">\r\n  <template is=\"renderName\" data=\"{{...data.name}\"/>\r\n</view>// bi.js\r\nComponent({\r\n  ready() {\r\n    // 根据 tpl 值选择解析函数\r\n    const formatData = helper[data.tpl]\r\n    this.setData({\r\n      data: formatData(data)\r\n    })\r\n  }\r\n})分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档：使用分包独立分包部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档 。白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成：网络资源加载时间 ；渲染时间 ；启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。小程序默认会按照 不同小程序 、 不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号 、 用户属性 来对缓存进行再隔离，避免信息误展示。数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力： 数据预拉取 。关于冷启动和热启动的定义可以看 这里数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方：预拉取的数据会被强缓存；由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。请求体和响应体都无法被拦截；由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。小程序内部接口的响应体类型都是 application/octet-stream ，即数据格式未知，使本地代理无法正确解析。微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息 ；如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类： 主体模块 （导航、商品轮播、商品豆腐块等）和 非主体模块 （幕帘弹窗、右侧挂件等）。在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块 （商品豆腐块以上部分） 和 非首屏模块 （商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。为了更好地呈现效果，上面 gif 做了降速处理接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用：wx.request\r\nwx.connectSocket\r\n超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此， 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。使用 WebP 格式WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。图片裁剪&降质鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片：裁剪成 100x100 的图片： https://{host}/s100x100_jfs/{file_path} ；降质 70%： https://{href}!q70 ；图片懒加载、雪碧图（CSS Sprite）优化这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。降级加载大图资源在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源， 我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染 。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。下面为大家提供部分例程：<!-- banner.wxml -->\r\n<image src=\"{{url}}\" />\r\n\r\n<!-- 图片加载器 -->\r\n<image\r\n  style=\"width:0;height:0;display:none\"\r\n  src=\"{{preloadUrl}}\"\r\n  bindload=\"onImgLoad\"\r\n  binderror=\"onErrorLoad\"\r\n/>// banner.js\r\nComponent({\r\n  ready() {\r\n    this.originUrl = 'https://path/to/picture'  // 图片源地址\r\n    this.setData({\r\n      url: compress(this.originUrl)             // 加载压缩降质的图片\r\n      preloadUrl: this.originUrl                // 预加载原图\r\n    })\r\n  },\r\n  methods: {\r\n    onImgLoad() {\r\n      this.setData({\r\n        url: this.originUrl                       // 加载原图\r\n      })\r\n    }\r\n  }\r\n})注意，具有 display: none 样式的 <image> 标签只会加载图片资源，但不渲染。京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。为了更好地呈现效果，上面 gif 做了降速处理骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。“白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的：<!-- index.wxml -->\r\n<skeleton wx:if=\"{{isLoading}}\"></skeleton>\r\n<block wx:else>\r\n  页面主体\r\n</block>但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。<!-- banner.wxml -->\r\n<view class=\"{{isLoading ? 'banner--skeleton' : ''}}\">\r\n  <view class=\"banner_wrapper\"></view>\r\n</view>// banner.scss\r\n.banner--skeleton {\r\n  @include skeleton;\r\n  .banner_wrapper {\r\n    @include skeleton__block;\r\n  }\r\n}上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作：1. 准备新的 webview 线程环境，包括基础库的初始化；2. 从逻辑层到视图层的初始数据通信；3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：降低线程间通信频次；减少线程间通信的数据量；减少 WXML 节点数量；合并 setData 调用尽可能地把多次 setData 调用合并成一次。我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（ 事件循环 ）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。// 小程序里的时间片 API\r\nconst nextTick = wx.nextTick ? wx.nextTick : setTimeout;只把与界面渲染相关的数据放在 data 中不难得出， setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系：上图来自小程序官方开发指南所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData 。附 Taro 框架的 数据 diff 规则去掉不必要的事件绑定当用户事件（如 Click 、 Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。去掉不必要的节点属性组件节点支持附加自定义数据 dataset （见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。<!-- wxml -->\r\n<view\r\n  data-a='A'\r\n  data-b='B'\r\n  bindtap='bindViewTap'\r\n>\r\n  Click Me!\r\n</view>// js\r\nPage({\r\n  bindViewTap(e) {\r\n    console.log(e.currentTarget.dataset)\r\n  }\r\n})适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、 setData 调用、 createSelectorQuery执行域等）。不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery来查找节点，过于庞大的节点树结构也会影响查找效率。我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智...事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示： Component A 组件中的变量 a 、 b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？<!-- Component A -->\r\n<component-b prop-a=\"{{a}}\" prop-b=\"{{b}}\" />// Component B\r\nComponent({\r\n  properties: {\r\n    propA: String,\r\n    propB: String,\r\n  },\r\n  methods: {\r\n    onLoad: function() {\r\n      this.data.propA\r\n      this.data.propB\r\n    }\r\n  }\r\n})推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码...）：一个全局的事件调度中心class EventBus {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  on(key, cb) { this.events[key].push(cb) }\r\n\r\n  trigger(key, args) { \r\n    this.events[key].forEach(function (cb) {\r\n      cb.call(this, ...args)\r\n    })\r\n  }\r\n  \r\n  remove() {}\r\n}\r\n\r\nconst event = new EventBus()事件订阅者// 子组件\r\nComponent({\r\n  created() {\r\n    event.on('data-ready', (data) => { this.setData({ data }) })\r\n  }\r\n})事件发布者// Parent\r\nComponent({\r\n  ready() {\r\n    event.trigger('data-ready', data)\r\n  }\r\n})子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递” 、 “展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了...）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 <template> 。实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。<!-- index.wxml -->\r\n<template name=\"render-component\">\r\n  <search-bar wx:if=\"{{compId === 'SearchBar'}}\" floor-id=\"{{index}}\" />\r\n  <nav-bar wx:if=\"{{compId === 'NavBar'}}\" floor-id=\"{{index}}\" />\r\n  <banner wx:if=\"{{compId === 'Banner'}}\" floor-id=\"{{index}}\" />\r\n  <icon-nav wx:if=\"{{compId === 'IconNav'}}\" floor-id=\"{{index}}\" />\r\n</template>\r\n\r\n<view\r\n  class=\"component-wrapper\"\r\n  wx:for=\"{{comps}}\"\r\n  wx:for-item=\"comp\"\r\n>\r\n  <template is=\"render-component\" data=\"{{...comp}}\"/>\r\n</view>// search-bar.js\r\nComponent({\r\n  properties: {\r\n    floorId: Number,\r\n  },\r\n  created() {\r\n    event.on('data-ready', (comps) => {\r\n      const data = comps[this.data.floorId] // 根据楼层位置取数据\r\n    })\r\n  }\r\n})貌似非常轻松地完成需求，但值得思考的是： 如果组件顺序调整了，所有组件的生命周期会发生什么变化？假设，上一次渲染的组件顺序是 ['search-bar'，'nav-bar'，'banner', 'icon-nav'] ，现在需要把 nav-bar 组件去掉，调整为 ['search-bar'，'banner', 'icon-nav'] 。经实验得出， 当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。原理很简单，每个组件都有各自隔离的节点树（ ShadowTree ），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff： 如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载 。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。内存预警小程序提供了监听内存不足告警事件的 API： wx.onMemoryWarning ，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好...）。不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval 、 setTimeout 定时器：// Page A\r\nPage({\r\n  onLoad() {\r\n    let i = 0\r\n    setInterval(() => { i++ }, 100)\r\n  }\r\n})即使如小程序的 <swiper> 组件，在页面进入后台态时依然是会持续轮播的。正确的做法是， 在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器 。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了...避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则：onPageScroll 事件回调使用节流；避免 CPU 密集型操作，譬如复杂的计算；避免调用 setData ，或减小 setData 的数据量；尽量使用 IntersectionObserver 来替代 SelectorQuery ，前者对性能影响更小；大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。小程序官方提供了一个 长列表组件 ，可以通过 npm 包的方式引入，有兴趣的可以尝试。总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷：1. Audits 审计工具的性能得分 86 ；2. 优化后的首屏渲染完成时间（FMP）：3. 优化前后的测速数据对比：然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。参考User-centric Performance MetricsReduce JavaScript Payloads with Tree Shaking小程序开发指南小程序官方文档Taro 官方文档探究WebP一些事儿京喜首页（微信购物入口）跨端开发与优化实践欢迎关注凹凸实验室博客： aotu.io或者关注凹凸实验室公众号（AOTULabs），不定时推送文章："}
{"title": "微信小程序自定义navigationBar顶部导航栏，兼容适配所有机型（附完整案例） ... ", "author": "Rolan", "time": "2020-3-27 00:37", "content": "本文首发自个人自有博客： 【FaxMiao个人博客】 ，一个关注Web前端开发技术、关注用户体验、记录前端点滴，坚持更多原创，为大家提供高质量技术博文！前言navigationBar相信大家都不陌生把？今天我们就来说说自定义navigationBar，把它改变成我们想要的样子（搜索框+胶囊、搜索框+返回按钮+胶囊等）。思路隐藏原生样式获取胶囊按钮、状态栏相关数据以供后续计算根据不同机型计算出该机型的导航栏高度，进行适配编写新的导航栏引用到页面正文一、隐藏原生的navigationBarwindow全局配置里有个参数：navigationStyle（导航栏样式），default=默认样式，custom=自定义样式。\"window\": {\r\n\t\"navigationStyle\": \"custom\"\r\n}\r\n复制代码让我们看看隐藏后的效果：可以看到原生的navigationBar已经消失了，剩下孤零零的胶囊按钮，胶囊按钮是无法隐藏的。二、准备工作1.获取胶囊按钮的布局位置信息我们用wx.getMenuButtonBoundingClientRect() 【官方文档】 获取胶囊按钮的布局位置信息，坐标信息以屏幕左上角为原点：const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n复制代码widthheighttoprightbottomleft宽度高度上边界坐标右边界坐标下边界坐标左边界坐标下面是官方给的示意图，方便大家理解几个坐标。2.获取系统信息用wx.getSystemInfoSync() 【官方文档】 获取系统信息，里面有个参数：statusBarHeight（状态栏高度），是我们后面计算整个导航栏的高度需要用到的。const systemInfo = wx.getSystemInfoSync();\r\n复制代码三、计算公式我们先要知道导航栏高度是怎么组成的， 计算公式： 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度 。实例 【源码下载】自定义导航栏会应用到多个、甚至全部页面，所以封装成组件，方便调用；下面是我写的一个简单例子：app.jsApp({\r\n    onLaunch: function(options) {\r\n        const that = this;\r\n        // 获取系统信息\r\n        const systemInfo = wx.getSystemInfoSync();\r\n        // 胶囊按钮位置信息\r\n        const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n        // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n        that.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n        that.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n        that.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n        that.globalData.menuHeight = menuButtonInfo.height;\r\n    },\r\n    // 数据都是根据当前机型进行计算，这样的方式兼容大部分机器\r\n    globalData: {\r\n        navBarHeight: 0, // 导航栏高度\r\n        menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n        menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n        menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n    }\r\n})\r\n复制代码app.json{\r\n    \"pages\": [\r\n        \"pages/index/index\"\r\n    ],\r\n    \"window\": {\r\n        \"navigationStyle\": \"custom\"\r\n    },\r\n    \"sitemapLocation\": \"sitemap.json\"\r\n}\r\n复制代码下面为组件代码： /components/navigation-bar/navigation-bar.wxml<!-- 自定义顶部栏 -->\r\n<view class=\"nav-bar\" style=\"height:{{navBarHeight}}px;\">\r\n    <input class=\"search\" placeholder=\"输入关键词！\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{menuHeight}}px; left:{{menuRight}}px; bottom:{{menuBotton}}px;\"></input>\r\n</view>\r\n\r\n<!-- \r\n    内容区域：\r\n    自定义顶部栏用的fixed定位，会遮盖到下面内容，注意设置好间距\r\n-->\r\n<view class=\"content\" style=\"margin-top:{{navBarHeight}}px;\"></view>\r\n复制代码/components/navigation-bar/navigation-bar.json{\r\n  \"component\": true\r\n}\r\n复制代码/components/navigation-bar/navigation-bar.jsconst app = getApp()\r\nComponent({\r\n    properties: {\r\n        // defaultData（父页面传递的数据-就是引用组件的页面）\r\n        defaultData: {\r\n            type: Object,\r\n            value: {\r\n                title: \"我是默认标题\"\r\n            },\r\n            observer: function(newVal, oldVal) {}\r\n        }\r\n    },\r\n    data: {\r\n        navBarHeight: app.globalData.navBarHeight,\r\n        menuRight: app.globalData.menuRight,\r\n        menuBotton: app.globalData.menuBotton,\r\n        menuHeight: app.globalData.menuHeight,\r\n    },\r\n    attached: function() {},\r\n    methods: {}\r\n})\r\n复制代码/components/navigation-bar/navigation-bar.wxss.nav-bar{ position: fixed; width: 100%; top: 0; color: #fff; background: #000;}\r\n.nav-bar .search{ width: 60%; color: #333; font-size: 14px; background: #fff; position: absolute; border-radius: 50px; background: #ddd; padding-left: 14px;}\r\n复制代码以下是调用页面的代码，也就是引用组件的页面： /pages/index/index.wxml<navigation-bar default-data=\"{{defaultData}}\"></navigation-bar>\r\n复制代码/pages/index/index.json{\r\n    \"usingComponents\": {\r\n        \"navigation-bar\": \"/components/navigation-bar/navigation-bar\"\r\n    }\r\n}\r\n复制代码/pages/index/index.jsconst app = getApp();\r\nPage({\r\n    data: {\r\n        // 组件参数设置，传递到组件\r\n        defaultData: {\r\n            title: \"我的主页\", // 导航栏标题\r\n        }\r\n    },\r\n    onLoad() {\r\n        console.log(this.data.height)\r\n    }\r\n})\r\n复制代码效果图：好了，以上就是全部代码了，大家可以文中复制代码，也可以 【下载源码】，直接到开发者工具里运行，记得appid用自己的或者测试哦！下面附几张其它小程序的效果图，大家也可以尝试照着做：总结本文写了自定义navigationBar的一些基础性东西，里面涉及组件用法、参数传递、导航栏相关。由于测试环境有限，大家在使用时如果发现有什么问题，希望及时反馈，以供及时更新帮助更多的人！大家有什么疑问，欢迎评论区留言！"}
{"title": "阿里盒马、腾讯小程序团队 —— 小菜鸡自闭の面经（等HRing...） ... ", "author": "Rolan", "time": "2020-3-27 00:42", "content": "俺这只小菜鸡:chicken:终于也快迎来曙光了！:grinning:俺现在是一名大三学生，渴望能获得一份大厂的实习机会呜呜呜，所以不自量力的投了一下阿里跟腾讯。阿里是提前批就开始面了的。很多部门都面了一下下，面了啥也忘了哈哈哈哈。也多亏了提前批，让俺知道哪些地方还需要再补补。阿里这边最终选择了盒马，盒马的面试官都好好，好和蔼，给了好多建议，没有因为我菜就嫌弃我呜呜呜，太感动了。而且！看到这张“ 屁股脸 ”难道不想加入换一套限量公仔/手办吗！个人の想法我觉得面试更像是一次学习的机会，可以查漏补缺，之后自己深入学习更多的东西我还是觉得大厂面试，还是得有一个自己熟悉的、参与度高的项目来展开，因为还是很多面试官会选择问问项目经历来了解我们。不会就是不会哈哈哈哈，老实承认就好，之后自己下去再找找资料补一补就好！不必沉浸在悲伤之中面试完之后，如果有问题，尽量积极主动的去寻找面试官请教，不要觉得不好意思或者说不敢这样子，我觉得就算即便是挂了也好，也可以请教一下学到更多的东东，不至于一场面试下来颗粒无收阿里の盒马初面初面是聊得最久的一次了，一个多小时了吧，不过初面的面试官真的很让人感动一直在鼓励我，“好啊好啊”，“没关系没关系”，啊太棒了，给俺这个小菜鸡很多信心hhhh输入url到页面展示浏览器存储如何实现继承跨域，常用哪个，解释一下缓存重绘回流性能优化React优势React生命周期React最佳实践React新特性如果列表组件要新增一些内容，例如标题，简介等，你会怎么对代码进行修改（容器组件 -> 展示组件）csrf 和 xssflex判断是否为数组typeof arr === 'object'浏览器事件循环，node事件循环事件委托webpack流程，插件koa源码koa洋葱模型mobx原理首屏优化async/await Promise盒模型babel原理Taro原理一面一面俺就放放笔试题还有俺自己做的情况吧哈哈哈哈，一面的面试官跟俺说拓扑排序，俺才知道原来还有这种东西（流泪...笔试题目给定一个链表，判断链表中是否有环，比如下图这种即为有环链表。加分项：使用空间复杂度 O(1) 实现分析一个项目的依赖结构，并按依赖优先级排序。 已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载每一个依赖不希望在钱多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：ProjectA\r\n- a@0.1.0\r\n    - d@0.2.0\r\n    - c@0.1.0\r\n- b@0.1.1\r\n    - e@0.1.2\r\n    - c@0.1.2\r\n- c@0.2.0\r\n复制代码则其中一种输出的依赖优先级排序为：['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']输出分析： 为了让 a 加载后可以争取执行，则必须先加载 d 和 c，b 的加载同理，又因为在整个依赖关系下，c 的最新版本为 0.2.0 于是有了如上的输出结果。请用 React 实现一个搜索框组件，功能包括：输入文本字数限制可配置输入文本约束，比如仅限输入数字用户输入时可支持关键字搜索，并出现下拉框展示相关项俺的答案第一题leetcode原题来的，环形链表好像是，可以用快慢指针或者简单的集合const cycle1 = function (node) {\r\n  let set = new Set()\r\n  while (node) {\r\n    if (set.has(node))\r\n      return true\r\n    else\r\n      set.add(node)\r\n    node = node.next\r\n  }\r\n  return false\r\n};\r\n\r\n\r\n\r\nconst cycle2 = function (node) {\r\n  let start = node\r\n  let end = node.next\r\n  while (start !== end) {\r\n    // 没有环就null\r\n    if (end === null || end.next === null) return false\r\n    start = start.next\r\n    end = end.next.next\r\n  }\r\n  return true\r\n}\r\n复制代码第二题的话我拿到题目第一个想到的就是DFS来寻找那些依赖，然后最后再对依赖这些进行版本比较（其实应该用集合、还有拓扑排序来优化）function update(npmList) {\r\n  let versions = {}\r\n  let res = []\r\n\r\n  // 比较版本号\r\n  function cmp(a, b) {\r\n    const versionA = getVersion(a).split('.')\r\n    const versionB = getVersion(b).split('.')\r\n    for (let index = 0; index < 3; index++) {\r\n      if (versionA[index] > versionB[index]) return a\r\n      else if (versionA[index] === versionB[index]) continue\r\n      else return b\r\n    }\r\n    return a\r\n  }\r\n\r\n  // 获得版本号\r\n  function getVersion(str) {\r\n    return str.substr(str.indexOf('@') + 1)\r\n  }\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, deps = [] } = npm\r\n      // 先遍历他们的依赖\r\n      dfs(deps)\r\n      let key = name.substr(0, name.indexOf('@'))\r\n      // 如果依赖不存在则添加，若已存在，则取最新版\r\n      if (!versions[key]) {\r\n        versions[key] = name\r\n      } else {\r\n        versions[key] = cmp(versions[key], name)\r\n      }\r\n      // 添加进最后的加载列表\r\n      res.push(key)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  // 去除重复项，然后将包名转换为依赖名，eg: a -> a@0.1.0\r\n  return [...new Set(res)].map(key => versions[key])\r\n}\r\n复制代码第三题的话，我粗略写了一下噗，写的也不是很好，用React整的// 第三题React部分第三题React部分第三题React部分第三题React部分第三题React部分\r\n\r\nimport React, { Component } from 'react';\r\nimport './input.css'\r\n\r\nfunction debounce(fn, delay = 500) {\r\n  let timeout = null\r\n  return function (e, ...args) {\r\n    e.persist && e.persist()\r\n    timeout && clearTimeout(timeout)\r\n    timeout = setTimeout(() => {\r\n      fn.call(this, e, ...args)\r\n    }, delay)\r\n  }\r\n}\r\n\r\nclass Tips extends Component {\r\n  render() {\r\n    const { tipsList } = this.props\r\n    return tipsList && tipsList.length !== 0 ? (\r\n      <div className=\"tips__container\">\r\n        {tipsList.map((item, index) => {\r\n          return (\r\n            <a href=\"#\" key={index} className=\"link\">{item}</a>\r\n          )\r\n        })}\r\n      </div>\r\n    ) : <div></div>\r\n  }\r\n}\r\n\r\nexport default class Input extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      keyWords: [\r\n        '前端工程师1', '前端高级开发1', '后端工程师1', '测试开发1', '项目主管1', 'dress', 'Recent', '123456', 'awdad1'\r\n      ],\r\n      inputValue: '',\r\n      inputType: 'text',\r\n      inputMaxLen: 20,\r\n      wordsList: []\r\n    }\r\n    this.handleInput = debounce(this.handleInput, 200)\r\n    this.handleMaxLenChange = debounce(this.handleMaxLenChange, 400)\r\n  }\r\n\r\n  handleInput = (e) => {\r\n    const { target: { value } } = e\r\n    const { keyWords } = this.state\r\n    const tipsList = !value\r\n      ? []\r\n      : keyWords.filter(item => {\r\n        const res = item.search(new RegExp(value, 'i'))\r\n        return res !== -1\r\n      })\r\n    this.setState({\r\n      inputValue: value,\r\n      tipsList\r\n    })\r\n  }\r\n\r\n  handleTypeClick = (e) => {\r\n    const { target: { name } } = e\r\n    this.setState({ inputType: name })\r\n  }\r\n\r\n  handleMaxLenChange = (e) => {\r\n    const { target: { value } } = e\r\n    const { inputValue } = this.state\r\n    const newInputValue = inputValue.substr(0, +value)\r\n    // 如果设置最大长度小于现在关键词的长度，则截取一下\r\n    this.input.value = newInputValue\r\n    this.setState({ inputMaxLen: value, inputValue: newInputValue })\r\n  }\r\n\r\n  render() {\r\n    const { tipsList, inputType, inputMaxLen } = this.state\r\n    return (\r\n      <div className=\"container\">\r\n        <div className=\"control__container\" onClick={this.handleTypeClick}>\r\n          <button name=\"text\">文本</button>\r\n          <button name=\"number\">数字</button>\r\n          <span>最大长度: </span>\r\n          <input type=\"number\" placeholder=\"默认: 20\" onInput={this.handleMaxLenChange} />\r\n        </div>\r\n        <div className=\"input__container\">\r\n          <div className=\"input__wrap\">\r\n            <input\r\n              ref={input => this.input = input}\r\n              placeholder=\"请输入关键词\"\r\n              type={inputType}\r\n              maxLength={inputMaxLen}\r\n              onInput={this.handleInput} />\r\n            <button>搜索</button>\r\n          </div>\r\n          <Tips tipsList={tipsList} />\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n复制代码// 第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分\r\n\r\n\r\n.container {\r\n  width: 600px;\r\n  height: 400px;\r\n  margin: 0 auto;\r\n  padding: 30px;\r\n  background: #fff;\r\n}\r\n\r\n.input__container {\r\n  margin-top: 30px;\r\n}\r\n\r\n.input__wrap {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.input__wrap input {\r\n  box-sizing: border-box;\r\n  width: 85%;\r\n  height: 50px;\r\n  padding: 0 10px;\r\n  border: #666 1px solid;\r\n  border-right: 0;\r\n  outline: none;\r\n}\r\n\r\n.input__wrap button {\r\n  cursor: pointer;\r\n  box-sizing: border-box;\r\n  width: 15%;\r\n  height: 50px;\r\n  color: #fff;\r\n  font-size: 20px;\r\n  border: none;\r\n  border: #666 1px solid;\r\n  outline: none;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.control__container button {\r\n  cursor: pointer;\r\n  width: 50px;\r\n  height: 30px;\r\n  margin-right: 10px;\r\n  color: #fff;\r\n  outline: none;\r\n  border: #333 1px solid;\r\n  border-radius: 8px;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container span {\r\n  margin-left: auto;\r\n  margin-right: 10px;\r\n  color: #666;\r\n  font-size: 14px;\r\n}\r\n\r\n.tips__container {\r\n  overflow-y: scroll;\r\n  max-height: 200px;\r\n  border: #333 1px solid;\r\n  border-top: 0;\r\n}\r\n\r\n.tips__container .link {\r\n  display: block;\r\n  height: 30px;\r\n  padding: 5px 10px;\r\n  color: #666;\r\n  line-height: 30px;\r\n  text-decoration: none;\r\n}\r\n\r\n.tips__container .link:hover {\r\n  color: #fff;\r\n  background: #666;\r\n}\r\n\r\ninput::-webkit-outer-spin-button,\r\ninput::-webkit-inner-spin-button {\r\n  display: none;\r\n}\r\n复制代码二面二面主要是结合项目来问的，抓住一个功能发散开来，例如我项目的聊天室的功能，吓得我好慌好慌hhh，不过面试官人很好一直引导我，特别是那些场景题，引导我去思考，啊，太感动了！！！项目の各种东东聊天私聊怎么做聊天记录未读消息怎么做聊天离线信息处理session会话管理如何实现（用户登录后，打开新标签页输入url访问资源）访问资源权限控制事件队列题websocket如何连接做题系统组件的设计与拓展（拓展更多类型的题目，如何设计组件）用户鉴权系统设计为什么密码表跟用户信息表分开放数据库表的设计三面这一面也是结合项目来问的。啊，三面的面试官真的太好了，期初我的小项目没什么难点（我都以为凉透透了呜呜呜），然后面试官给了提了几个建议，让我多去深入思考思考，面试完之后去找他请教问题，也一直很有耐心给我指导指导，啊，太棒了吧项目の各种东东飞猪为什么挂了项目难点小程序登录怎么做的封装了什么组件建议：在线阅卷、批注、修改错别字等（canvas绘制）建议：实时监控每个同学的进度（选择答案后之后教师端更新/摄像头监控）a与b聊天，将他们的记录，多选，然后合并发给c，如何设计除了编译成小程序，有试过app吗四面四面应该是总监面，还是得感谢三面的面试官给我提的建议，之后做出来之后，发现这个东东可以作为项目的一个难点来吹哈哈哈！四面主要还是围绕项目来问，我个人觉得关注的更是自己的思维、对技术的认识、对自己未来的发展规划等宏观的内容就是这个小功能，canvas实现作业批注等功能项目难点（canvas绘制公式websocket实现，聊天功能的实现（心跳检测，断线重连项目の细节聊天信息的一致性，时序性目标、具体想通过实习学到什么技术规划，之后学些什么五面五面是交叉面，心惊胆跳呜呜呜，希望不要挂我...五面问的大多是基础方面的内容，不过也是结合项目来问的，这一面面试官主要关注的是 性能 方面的内容，例如数据埋点啊、页面加载时间、接口响应时间等一系列关于性能方面的问题，他希望的是数据量化的一个东东，具体的实现，达成了什么目标等项目做了那些事情小程序运行池小程序和H5的区别缓存存在哪（强缓存、协商缓存分别通过什么字段保存React与Vue的区别React的优势Taro编译的机制Taro支持的端有哪些node的机制、优势项目的难点，如何解决，遇到的问题如何监控性能尝试做了哪些性能上的优化收集用户信息？数据埋点？性能指标？量化指标？资源大小，加载速度，页面渲染时间，接口访问时间如何优化node后台的接口（sql优化，表结构重写使用什么服务器，部署在什么操作系统上多人同时访问接口测试过吗？最高承载多少webpack如何减小资源打包大小擅长什么你的优势是什么目标？规划？腾讯の小程序一面一面是笔试 + 面试，俺也放放题目跟俺的答案吧！笔试题目实现⼀个函数 reverse(a, n) ，反转⼀个含有 n 个整数的数组 a（直接在数组a上操作，元素交换次数 尽可能少，不能使⽤js Array 类内置属性和⽅法）。实现⼀个函数 countLongest(tree) ，输⼊⼀棵⼆叉树，返回⼆叉树中距离最⻓的两个叶⼦节点之间 的距离。var x = [0, 1, 2, 3]\r\nreverse(x, 4) // x = [3, 2, 1, 0]\r\nvar y = [1, 2, 3, 4, 1]\r\nreverse(y, 5) // y = [1, 4, 3, 2, 1]\r\nvar tree1 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}\r\ncountLongest(tree1) // 2\r\nvar tree2 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}\r\ncountLongest(tree2) // 4\r\n复制代码在前端开发中，通常会把多个js⽂件合并成⼀个⽂件，以减少⽹络请求次数，达到优化加载速度的⽬ 的，但是当⽂件之间存在依赖关系时，对js合并的顺序，会有⼀定的要求，⽐如 A.js 依赖了 B.js，那打 包后的⽂件，B.js 需要排在 A.js 的前⾯。 实现⼀个函数 resolve(tree) ，根据js的依赖关系树 tree，输出合理的打包顺序的数组（结果可能不 唯⼀，输出其中⼀种即可）。样例var tree1 = {\r\n  name: 'main.js',\r\n  require: [{\r\n    name: 'A.js'\r\n  }, {\r\n    name: 'B.js'\r\n  }]\r\n}\r\nresolve(tree1) // ['A.js', 'B.js', 'main.js']\r\nvar tree2 = {\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}\r\nresolve(tree2) // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']\r\n复制代码给定⼀个整数数组 a，实现⼀个函数 countMax(a) ，计算出从 a 中选择出多个不相邻元素组成最⼤的 和是多少。样例var x = [1, 4, 5, 3]\r\ncountMax(x) // 7\r\nvar y = [3, 12, 6, 2, 4]\r\ncountMax(y) // 16\r\n复制代码俺的答案就是简单的倒置hhhfunction reverse(arr) {\r\n  let len = arr.length\r\n  for (let start = 0; start < Math.floor(len / 2); start++) {\r\n    let end = len - start - 1;\r\n    [arr[start], arr[end]] = [arr[end], arr[start]]\r\n  }\r\n  return arr\r\n}\r\n复制代码这题是leetcode原题好像，就算算深度function countLongest(tree) {\r\n  if (!tree) return 0\r\n  let res = 0\r\n\r\n  function dfs(node) {\r\n    if (!node) return 0\r\n    const leftMax = dfs(node.left)\r\n    const rightMax = dfs(node.right)\r\n    res = Math.max(leftMax + rightMax, res)\r\n    return Math.max(leftMax, rightMax) + 1\r\n  }\r\n  dfs(tree)\r\n  return res\r\n}\r\n\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}))\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}))\r\n复制代码第三题是不是很眼熟哈哈哈，跟盒马一面的笔试题好像（其实我发现很多面试笔试题都有这相关的影子）还是DFS来找function resolve(npmList) {\r\n  const res = []\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, require = [] } = npm\r\n      dfs(require)\r\n      !res.includes(name) && res.push(name)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  return res\r\n}\r\n\r\n\r\nconsole.log(resolve([{\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}]))\r\n复制代码用动态规划来找function countMax2(arr) {\r\n  const len = arr.length\r\n  const dp = new Array(len).fill(0);\r\n  dp[0] = arr[0]\r\n  dp[1] = arr[1]\r\n  dp[2] = arr[0] + arr[2]\r\n  // [1, 4, 7, 0]\r\n\r\n  // [3, 12, 9, ...], \r\n  // [3, 12, 9, 14, ...],\r\n  for (let i = 3; i < len; i++) {\r\n    dp[i] = arr[i] + Math.max(dp[i - 2], dp[i - 3])\r\n  }\r\n  return dp[len - 1]\r\n}\r\n\r\nconsole.log(countMax2([1, 4, 5, 3]))\r\nconsole.log(countMax2([3, 12, 6, 2, 4]))\r\n// console.log(countMax2([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7]))\r\n复制代码面试内容项目为什么用token不用cookie跨域（前端跟前端的跨域，iframe之间）xssReact与Vue的对比Taro与其他多端框架主要还是项目发散如何实现轮播图二面二面基本都是一些基础吧，但是就有些地方会深入去挖这样子https原理，握手过程(何时对称/非对称，谁先谁后，为什么这样)常见的优化webp格式优化了多少缓存以键值形式存在浏览器，键是什么，值是什么设计一个缓存策略，（hash值）React的keyReact与Vue的区别Taro与小程序官方框架的区别小程序运行池React列表key固定，顺序调换会渲染吗（不会）如何判断性能瓶颈项目の各种东东三面三面感觉还不够二面难，问的比较常见吧应该说，然后也是问问项目这样子算法：判断数组中是否存在两个数相加等于目标值，给出多种思路与时间空间复杂度（暴力循环，排序后循环剪枝，动态规划）es6的class如何实现私有变量（symbol + 闭包）如何进行性能监控常见的性能优化方法内存泄露如何发现，如何解决垃圾回收机制跨域（cors + jsonp + 其他不常见的跨域方法）浏览器缓存实现深拷贝，深拷贝的用途xss、csrfcookie与token的工作原理，区别，如何设计http1.1、http2.0http无状态websocket是什么协议，如何连接websocket有什么优势，对比轮训呢事件循环setTimeout是否准时，如果不是则应该提前还是延迟webpack流程常见的http状态码babel原理、taro原理map中的键值会不会被回收（weakMap，weakSet等）项目....难点、设计、收获平时如何学习"}
{"title": "iPhoneX安全区域(Safe Area)底部小黑条在微信小程序和H5的屏幕适配 ... ", "author": "Rolan", "time": "2020-3-30 00:31", "content": "最近写小程序时，遇到了 iPhoneX 底部小黑线与内容重叠的问题，实际上是iPhoneX安全区域的适配问题，了解清楚这个问题花了挺多时间的，也实操出了结果，忍不住来总结总结。本文目录前言· 内容与小黑线重叠情况说明1.安全区域含义2.微信小程序适配iPhoneX底部小黑条(Home Indicator)（1）适配方案一：使用已知底部小黑条高度34px/68rpx来适配（不推荐）（2）适配方案二：使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）（3）适配方案三：使用苹果官方推出的css函数env()、constant()来适配 （推荐） 3.H5适配iPhoneX底部小黑条(Home Indicator)        · 适配方案：使用苹果官方推出的css函数env()、constant()来适配 （推荐）前言在苹果 iPhoneX 、iPhone XR等设备上，可以看到物理Home键被取消，改为底部小黑条替代home键功能。微信小程序和 h5 网页需要针对这种情况进行适配，否则可能会遇到底部按钮或选项卡栏与底部黑线重叠的情况，如下图。1. 安全区域是什么意思？想要解决内容与小黑线重叠的问题，我们需要先了解清楚苹果对于安全区域的定义。安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角(corners)、齐刘海(sensor housing)、小黑条(Home Indicator)的影响。看看苹果官方给的这2张图就明白了，中间蓝色区域即为安全区域。也就是说，适配安全区域也就是让小程序或者H5的内容显示在蓝色区域部分。同时安全区域是在IOS11之后并且是iPhoneX及以上机型才有的，所以需要适配的是这一类机型（为了方便，下文中统称这类需要适配的机型为iPhoneX），更老的机型则不需要考虑适配问题。2. 在微信小程序上适配安全区域三种方案：使用已知底部小黑条高度34px/68rpx来适配（不推荐）使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）使用苹果官方推出的css函数env()、constant()适配（推荐）方案一：使用已知底部小黑条高度34px/68rpx来适配（不推荐）这是比较老的方法，跟方案2、3比已经不推荐了，大家可以了解了解，着急可以直接看方案2和3。从网上了解到，iPhone底部的小黑条（Home Indicator）高度是34px，实际我也在真机确认了是34px，所以可以根据该值，设置底部按钮或选项卡的margin-bottom、padding-bottom、height等，或者添加一个div来占位小黑条的位置。这样做要有一个前提，需要判断当前机型是需要适配安全区域的机型。问题：如何判断当前机型是需要适配安全区域2种方案：使用 wx.getSystemInfoSync() 的 model 属性判断使用 wx.getSystemInfoSync() 中的 screenHeight 和 safeArea 对象的 bottom 属性判断方法一：使用 wx.getSystemInfoSync() 的 model 属性判断已知市面上已有的带安全区域的苹果设备包括iPhone X、iPhone XR、iPhone XS Max、iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max，所以可以直接从getSystemInfoSync()方法中拿到model属性进行判断。iPhone系列微信还未适配手机的model返回值为unknown(iphone)，也可以提前做适配。let IPHONE_X = /iphone x/i\r\nlet IPHONE_X_11 = /iphone 11/i\r\nlet IPHONE_UNKNOWN = /unknown\\(iphone\\)/i\r\n\r\n//方法一：使用model判断是否是IPhoneX及其他包含安全区域的机型手机\r\nconst isIPhoneX = () => {\r\n  let model = wx.getSystemInfoSync().model\r\n  return (model.search(IPHONE_X) > -1 || model.search(IPHONE_X_11) > -1 ||\r\n    model.search(IPHONE_UNKNOWN) > -1)\r\n}\r\n\r\n//也可以使用正则表达式判断\r\nconst isIPhoneXRegex = () => {\r\n  let model = wx.getSystemInfoSync().model\r\n  return (/iphone\\sx/i.test(model)\r\n    || (/iphone/i.test(model) && /unknown/.test(model))\r\n    || /iphone\\s11/i.test(model)) \r\n}\r\n复制代码方法二：使用 wx.getSystemInfoSync() 中的 screenHeight 和 safeArea 对象的 bottom属性判断这里使用 screenHeight 而不是 windowHeight ，因为 bottom 是以屏幕左上角为原点开始计算的，所以需要的是屏幕高度，对比 screenHeight 和 bottom ，如果相等则说明不需要适配，不相等则需要适配。**注意：**如果使用微信开发者工具中的模拟器，screenHeight和bottom始终是相等的，需要用真机来测试。//方法二：使用wx.getSystemInfoSync()中的screenHeight和safeArea的bottom判断\r\nconst isIPhoneX = () => {\r\n  let screenHeight = wx.getSystemInfoSync().screenHeight\r\n  let bottom = wx.getSystemInfoSync().safeArea.bottom\r\n  return screenHeight !== bottom\r\n}\r\n复制代码解决了如何判断设备是iPhoneX的问题，就可以写代码了。<view class=\"bottom-button {{isIpX ? 'view-IPX' : ''}}\">底部按钮</view>\r\n复制代码方案二：使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）使用wx. getSystemInfo()中的safeArea对象获取底部小黑条的高度step 1：使用上面讲的方法先判断是否是需要适配的iPhone机型 step 2：如果是需要适配的机型，使用safeArea中的bottom，得到安全区域底部纵坐标，然后使用screenHeight减去bottom就能得到小黑条的高度。保存到localstorage里面，全局都可以使用。方案三：使用苹果官方推出适配方案css函数env()、constant()来适配 （推荐）苹果官方推荐使用 env() ， constant() 来适配，建议使用该方案，不需要管数值具体是多少。这2个方法是什么呢？env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量：safe-area-inset-left：安全区域距离左边边界的距离safe-area-inset-right：安全区域距离右边边界的距离safe-area-inset-top：安全区域距离顶部边界的距离safe-area-inset-bottom ：安全距离底部边界的距离因为目标是需要对底部小黑条做适配，所以只需要关注 safe-area-inset-bottom 这个值。而env()和constant()函数有个必要的 使用前提 ，当网页设置 viewport-fit=cover 的时候才生效，根据微信小程序的表现和我在实际真机测试时这两个函数生效，推测小程序里的 viewport-fit 默认是 cover 。有一点要注意，在IOS11.2系统以前，可以使用constant()函数，但是在IOS11.2系统以后，这个函数就被废弃了，被env()函数替代了。官方原话如下：The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.\r\n所以我们在做屏幕适配时，需要这样写：padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS<11.2*/\r\npadding-bottom: env(safe-area-inset-bottom); /*兼容 IOS>11.2*/\r\n复制代码**注意：**env()和constant()需要同时存在，而且顺序不能换。3. 在H5上适配安全区域在H5上适配安全区域就方便多了，采用viewport+env+constant方案。viewport-fit 默认有3个值：contain：可视窗口完全包含网页内容（左图）cover：网页内容完全覆盖可视窗口（右图）auto：默认值，此值不影响初始布局视图端口，并且整个web页面都是可查看的。contain和cover具体区别如下图：而我们需要将viewport设置为cover，env和constant才能生效。设置代码如下：<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,viewport-fit=cover\">\r\n\r\n复制代码同时设置env和constant代码，同样env()和constant()需要同时存在，而且顺序不能换。/* 可以通过增加padding-bottom来适配 */\r\npadding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS<11.2*/\r\npadding-bottom: env(safe-area-inset-bottom); /*兼容 IOS>11.2*/\r\n\r\n/* 可以通过margin-bottom来适配 */\r\nmargin-bottom: constant(safe-area-inset-bottom);\r\nmargin-bottom: env(safe-area-inset-bottom);\r\n\r\n/* 或者改变高度*/\r\nheight: calc(55px +  constant(safe-area-inset-bottom));\r\nheight: calc(55px +  env(safe-area-inset-bottom));\r\n复制代码也可以在底部添加一个空白的div颜色块来做适配。还有一种是使用 @supports 隔离兼容样式可以使用 @supports 来隔离兼容样式，当浏览器支持 bottom: constant(safe-area-inset-bottom) 或者 bottom: env(safe-area-inset-bottom) 的时候， bottom-button 类就会新增 margin-bottom 的样式@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) { \r\n\t.bottom-button {\r\n    \tmargin-bottom: constant(safe-area-inset-bottom);\r\n        margin-bottom: env(safe-area-inset-bottom);  \r\n    }\r\n}\r\n复制代码以上就是我对iPhoneX安全区域(Safe Area)底部小黑条在微信小程序和H5适配的总结。如果对你有帮助的话，点赞、评论、赞赏都是对我的鼓励，也是支持我写下去的动力，谢谢！参考文章：网页适配 iPhoneX，就是这么简单苹果官方开发者文档关于屏幕适配的说明微信小程序吸底区域适配iPhone X微信小程序适配 iPhone X 总结本文原创发布于微信公众号「程序员张晴天」，欢迎关注第一时间获取最新分享，一起进步。"}
{"title": "实现微信小程序编译和运行环境系列(进阶篇) ", "author": "Rolan", "time": "2020-3-30 00:42", "content": "距离上一篇初始篇过了一段时间,在初始篇里面主要分享了微信小程序工具 和微信小程序的文件组成以及小程序架构的基本大纲和描述，看了第一篇的小伙伴应该大概知道了微信小程序运行时候各部分文件职能了,如果不太了解的话可以再去看下 github csdn进阶篇内容主要从以下几个方面来分享下微信小程序的架构核心文件WAService.js WAWebview.js appservice.js的解析 和其他文件在逻辑层和渲染层的:warning:注意事项websocket通信在微信小程序框架中的应用实现通过几个案例和部分代码来实现自己的小程序运行环境微信小程序云开发和小游戏架构初步分析(后续会持续更新)正文WAService.js文件在第一篇里面有讲到WAService.js文件是在 逻辑层 模版页面里面引入的，但是没有给予过多的介绍， 接下来主要分析下WAService.js的代码组成，这个文件算是微信小程序基础库文件里面很核心的文件了，所以微信对它的保护应该很到位了，微信通过了压缩 编译 打包后生成的一坨这个js文件(如下图)直接看完全没什么头绪，看着头很重！！下面只有让我们来一步一步分解它，让它原形毕露第一步让它变得看起来稍微美一点，毕竟大家都喜欢美一点的人事物， 既然有需求那肯定有解决方案，所以给大家推荐一个工具包js-beautify,可以先让代码看起来比原来漂亮很多直接执行命令(不要对他抱太大期望，美化后的不可能让你一步到位，还是要慢慢咔哧咔哧)js-beautify ./WAService.js -r\r\n复制代码美化后的代码看着花花绿绿的还是要舒心很多，但是毕竟人家是一个6万多行编译后的大物，想看明白不是一件易事，但我们还是要和它死磕来慢慢消耗它，接下里给大家介绍下个我 比较笨也是蛮傻的一种方案就是一点点有策略性的手动给他反编译过来(中间的过程只有经历后才能明白其中的痛啊)不过看到结果还是蛮欣慰的先给大家看下最终大部分解出来的编译文件如下图上面的图是通过分析代码还原的一些人看的代码，然后分类的在网上我有看到有人说通过一些工具对 WAService.js 进行格式化后进行 debug来分析，这种方式也是ok的但是有一些门槛问题，对于一些同学来说不太方便也不太能处理，因为你没有调试这些文件的运行环境，在微信开发者工具里面你是看不到WAService.js文件的更不要说去调试了，如果非要在开发者工具调试的话方法也是有的，要通过修改微信开发者工具客户端的代码才可以但是一般都不知道怎么去修改基础库代码下面介绍一个好理解但是有点痛苦的方式，比较清晰的一个操作是在上面我们让它变得美一点了，现在让它变得有条理一些，推荐使用vscode格式化后进行方法折叠这样一看其实很清晰了我们可以看到这些我们常听说的一些微信对象，WeixinJSBridge、 NativeBuffer、 wxConsole、 WeixinWorker、Reporter、VirtualDom等对象都打包一起了， 然后看到对象里面有很多个function(e,t,n)文件对应的就是每个暴露的方法，下面要做的就是把这些方法的代码手动编译过来，可以给大家一个案例演示下下图这个是VirtualDom对象文件里面的一个方法下图的是上面的代码改成我们正常人读的代码这个过程对你的js水平要有一定要求的，如果你基础不扎实和了解怎么应用的话，还原起来可能会很吃力的，如果你可以完整的编译这些文件的话，你的js水平完全可以超越大部分人可以先给大家简单分析一点非技术层面的一些疑问，具体的技术层面编译过程，可以熟悉js整个编译历史，和es6转es5的方式推荐大家熟悉下babel源码，可以有很多收获 由于本人也还比较小白（高手可以忽略这点） 大家可以看到var i=n(22)我改成了const DomIndex=require('./domIndex')这个语句语意可能很多人都可以理解，但我为什么把22这个文件写成DomIndex， 其实这里面的变量和命名和对应的文件都不是自己想当然的，这个可以在文件中进行分析得到的，具体怎么分析的这里不过多介绍了，内容就太多了有兴趣可以留言讨论使用对 WAService.js文件分析可以看出大致有 ： WeixinJSBridge、 NativeBuffer、 wxConsole、 WeixinWorker、 Reporter、 wx、 exparser、 virtualDOM 、 appServiceEngine 等对象组成的WAWebview.js文件这个大致和WAService.js文件分析方式一样，大家感兴趣的可以自行尝试下，留给大家自己研究，理解的肯定比我写出来的要深刻很多appservice.js文件这个文件分析的结果可以让我们看到一些浮出水面的东西来，但这个过程比较曲折开始 在微信小程序工具的渲染层和逻辑层里面和微信基础库都没有发现这个文件，说明可能是运行时注入进去的(猜测的)，后来在sources里面有发现这个文件但是文件是空的，页面资源和network里面都没有找到对应的文件，一时比较绝望，后来就一直瞎折腾半天后，终于在工具包里面appservice找到来这个类似文件，让生活注入了一点希望但是一打开还是这一坨不是人看的代码，但奈何不看不行啊(阿弥陀佛)通过分析研究发现，还是发现了一些蛛丝马迹，看到了这个文件里面存在webstocket和http通信方式，有通信说明就会和外界有关联，于是大胆尝试了在一些通信相关代码的地方，修改了一点代码和添加了日志标记三就是稍微在原来微信appservice.js的基础上进行了一点修改，然后保存，期待这微信开发者工具上面会有一些不一样的烟火:fireworks:，但奈何关了又开，开了又关半天屁的变化都没有，于是就产生了自我怀疑，难道不应该这样吗，但是还是感觉方向是对的，于是打算在试试终极解决方法《重启电脑》,果然当我在打开开发者工具的时候看到了不一样的烟火:fireworks:， 在console里面出现了耀眼的光芒，这里应该算一个突破性进展吧！！！看到api和返回的结果，发现这些其实就是微信提供对外的同步api,可以看到getSystemInfo走的其实是同步的方式，那微信还提供了getSystemInfoSync说明也是同步的，他们的底层实现都是同步的不知道这个api还提供这两个接口有什么意义 没理解， 然后又试了下其他微信提供的同步方法发现都会出现在这里，其他很多异步api的不会走这里都是通过webstocket走的，这里可以得出结论这些同步api请求都是通过/apihelper/assdk传输的，大家可以自己测试下拦截这个请求会发现更多内容。至于这个文件和基础库的关联和最核心的webstocket的实现和在文章开头说的案例分析和云开发小游戏架构分析相关，我打算放在下几篇《核心篇》里面来一一分享，本来打算放在一起的，但写起来才发现虽然文字不多但考虑东西太多时间要很久，如果放在一起只是大概概括的话会很快少很多省时省力，但是感觉没太大意义可能对一些想了解的同学没有太大帮助，所以我就想通过我中途的过程和遇到的问题来分析可能会好理解一些创作不易 点个赞支持一下就是动力！！欢迎感谢持续关注！！！"}
{"title": "微信小程序api封装经验 ", "author": "Rolan", "time": "2020-3-30 00:59", "content": "写多 之后，吸取之前的经验，瞎写了一个简单的封装api，有幸看到的朋友，就随便看看哈，如果能给到你帮助就一直棒了，额呵呵呵！新建constant.js和api.js文件　　　　  在constant.js中统一定义ip地址　　　　  api.js文件　　　对应的返回状态码要根据怎么公司的返回码的规定改了哈let CONSTANT = require('./constant')\r\n    // 从本地存储Storage中获取token值\r\nfunction getToken() {\r\n    return wx.getStorageSync(CONSTANT.TOKEN);\r\n}\r\n\r\n// 创建请求头header的内容\r\nfunction buildHeaders(isJson) {\r\n    let headers = {\r\n        \"Content-Type\": isJson ? 'application/json' : \"application/x-www-form-urlencoded\",\r\n        \"version\": CONSTANT.MINI_VERSION,\r\n    };\r\n    const token = getToken();\r\n    if (token) {\r\n        headers[\"token\"] = token;\r\n    }\r\n    return headers;\r\n}\r\n\r\n// 发起 HTTPS 网络请求。\r\nlet baseURL = CONSTANT.API_URL;\r\n\r\nfunction fetchApi(baseURL, url, params, method, isJson) {\r\n    // wx.getNetworkType判断网路类型。eg：wifi、2g、3g...;none值表示无网路\r\n    wx.getNetworkType({\r\n        success: function(res) {\r\n            // &&表示“并”\"none\" === e.networkType如果为真，才会去执行&&后面的内容，否则不执行\r\n            \"none\" === res.networkType && (wx.hideLoading(), wx.showModal({\r\n                title: \"提示\",\r\n                content: \"当前无网络，请检查网络设置后重新加载\",\r\n                showCancel: false\r\n            }));\r\n        }\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url: `${baseURL}${url}`,\r\n            method: method,\r\n            header: buildHeaders(isJson),\r\n            data: params,\r\n            success: function(res) {\r\n                // 成功返回statusCode参数表示开发者服务器返回的 HTTP 状态码\r\n                // 统一拦截提示错误\r\n                // var o = res.statusCode;\r\n                // if (o !== 200 && [21020000, 41020001, 41020003, 21020002].indexOf(res.data.status) == -1) {\r\n                //     wx.hideLoading();\r\n                //     wx.showModal({\r\n                //         title: \"提示\",\r\n                //         content: res.data.msg\r\n                //     });\r\n                //     return;\r\n                // } 2020.3.9\r\n                // 41020001表示未登录那就要去拿code值\r\n                // 21020002表示登录超时\r\n                // 并重新请求获取token值\r\n                if (41020001 == res.data.status || 21020002 === res.data.status) {\r\n                    wx.login({\r\n                        success: res => {\r\n                            wx.request({\r\n                                url: baseURL + \"/api/user/login\",\r\n                                method: \"GET\",\r\n                                header: {\r\n                                    \"token\": \"\",\r\n                                    \"version\": CONSTANT.MINI_VERSION,\r\n                                },\r\n                                data: {\r\n                                    code: res.code,\r\n                                },\r\n                                success: function(res) {\r\n                                    wx.removeStorageSync(CONSTANT.TOKEN);\r\n                                    if (21020000 === res.data.status) {\r\n                                        wx.setStorageSync(CONSTANT.TOKEN, res.data.data);\r\n                                        console.log(\"already refresh token\");\r\n                                        fetchApi(url, url, params, method);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                // 41020003表示未授权了直接跳转到授权页（请求授权获取用户信息）\r\n                else if (41020003 == res.data.status) {\r\n                    wx.redirectTo({\r\n                        url: \"/pages/accredit/accredit\"\r\n                    });\r\n                } else {\r\n                    resolve(res.data);\r\n                }\r\n            },\r\n            fail: function(res) {\r\n                reject(res.data);\r\n                console.log(\"network fail.\", res);\r\n            },\r\n            complete: function(res) {\r\n                reject(res.data);\r\n                // console.log('complete', res);\r\n            }\r\n        });\r\n    });\r\n};\r\nmodule.exports = {\r\n    // 首页\r\n    getIndex(params) {\r\n        return fetchApi(baseURL, '/api/index', params, 'GET');\r\n    },\r\n}引用　　在需要的页面引用，也可以只引用你需要的那一个方法也行的额　　　　api.getIndex().then(res => {　　......\r\n    //那到返回值之后要执行的内容\r\n}哈哈哈，完了"}
{"title": "使用uni-app开发叮咚买菜的一些笔记（附源码） ", "author": "Rolan", "time": "2020-3-31 00:05", "content": "本项目纯开源免费, 商品信息均来自网络,如有侵权,请联系作者,我会及时删除!前一段,看到一个大佬写的叮咚买菜,挺好,于是乎自己在家也琢磨了一下,自己搞了一版本,记录一些uni-app的开发事项,纯属个人总结,不对之处,还请指教!功能不是很全面,以后决定作为一个系列,持续更新一.预览:在线预览地址: http://dingdong.nodebook.top/GitHub: https://github.com/cgq001/din...管理后台: http://dingdong-admin.nodeboo...如果你觉得还凑合,给个start怎么样? 我会继续努力完善项目,争取做到前后台完整开源1.首页2.分类3.加入购物车4.收货地址5.我的二.项目简介1.vant Ui库在uni-app中使用H5版Ui库本站采用vant的H5版本(打包小程序和APP请使用vant的小程序版)UI库npm init # 初始化package.json文件\r\nnpm i vant -S # 通过npm安装vant的H5版本vant H5版本的使用(全局引入)main.jsimport Vant from 'vant';\r\n\r\nVue.use(Vant);\r\n\r\n//对vant进行注册,注意这里没有引入vant的样式文件,在main.js中 引入样式文件会报错,请在App.vue中引入App.vue<style>\r\n    @import 'vant/lib/index.css';\r\n</style>2.colorui UI库个人比较喜欢这个库炫酷的样式效果请在其官网: https://www.color-ui.com/ 下请将下载的colorui 文件夹复制到我们的项目根目录(注意 是CSS 本版的,犹豫是 H5项目,请不要复制wxss版本)然后在App.vue的style中 引入CSS文件即可三.关于uni-app中请求的简单封装1.简单封装import store from './state/index.js'  //vuex\r\n\r\n//封装request方法 无token\r\nconst request = (url, method, data) => {\r\n    var promise = new Promise((resolve, reject) => {\r\n        //提示一下\r\n        uni.showLoading({\r\n            title: '加载中...'\r\n        })\r\n        //网络请求\r\n        uni.request({\r\n            url: store.state.user.http+url, //store.state.user.http 为公共接口地址\r\n            data: data,\r\n            method: method,\r\n            header: {\r\n                \r\n            },\r\n            success: function (res) {\r\n                uni.hideLoading()\r\n                //服务器返回数据\r\n                if (res.statusCode == 200) {\r\n          \r\n                    if(res.data.code === 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    }else if(res.data.code != 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'none',\r\n                            duration: 2000\r\n                        });\r\n                    }\r\n                    \r\n                     resolve(res);\r\n                } else {\r\n                    //返回错误提示信息\r\n                    reject(res.data);\r\n                }\r\n            },\r\n            fail: function (e) {\r\n                 uni.hideLoading()\r\n                uni.showToast({\r\n                    title: '网络连接错误',\r\n                    icon: 'loading',\r\n                    duration: 2000\r\n                });\r\n                reject('网络出错');\r\n            }\r\n        })\r\n    });\r\n    return promise;\r\n}\r\n//封装request 含token\r\nconst requests = (url, method, data={}) => {\r\n    var promise = new Promise((resolve, reject) => {\r\n        //提示一下  loading动画 可根据需要开启\r\n        // uni.showLoading({\r\n        //     title: '加载中...'\r\n        // })\r\n        //console.log(store.state.user.token)  // 这里是从vuex中获取token信息,来判断是否登陆\r\n        if(!store.state.user.token || store.state.user.token === null ){\r\n            uni.navigateTo({\r\n                url: '/pages/login/login'\r\n            });\r\n            \r\n            return false;\r\n        }\r\n        //网络请求\r\n        uni.request({\r\n            url: store.state.user.http+url, //store.state.user.http 为公共接口地址\r\n            data: data,\r\n            header:{\r\n                \"Authorization\":store.state.user.token  //'Bearer '+\r\n            },\r\n            method: method,\r\n            success: function (res) {\r\n                uni.hideLoading()\r\n                //服务器返回数据\r\n                if (res.statusCode == 200) {\r\n                    if(res.data.code === 400){\r\n                        uni.navigateTo({\r\n                            url: '/pages/login/login'\r\n                        });\r\n                        \r\n                        return false;\r\n                    }\r\n                    //根据code码 判断 和 msg提示文字 做出响应的提示\r\n                    if(res.data.code === 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    }else if(res.data.code != 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'none',\r\n                            duration: 2000\r\n                        });\r\n                    }\r\n                    \r\n                     resolve(res);\r\n                } else {\r\n                    \r\n                    console.log(\"请求错误\")\r\n                    //返回错误提示信息\r\n                    reject(res.data);\r\n                }\r\n                \r\n            },\r\n            fail: function (e) {\r\n                \r\n                 uni.hideLoading()\r\n                uni.showToast({\r\n                    title: '网络连接错误',\r\n                    icon: 'loading',\r\n                    duration: 2000\r\n                });\r\n                reject('网络出错');\r\n            }\r\n        })\r\n    });\r\n    return promise;\r\n}\r\n//这里导出两个 请求 一个包含Token  一个包含token  请选择使用\r\nmodule.exports = {\r\n    request:request,\r\n    requests:requests\r\n}2.挂载import Vue from 'vue'\r\nimport App from './App'\r\nimport store from './static/state/index.js'\r\nVue.config.productionTip = false\r\n\r\n//引入封装的 请求文件\r\nconst https = require('./static/http.js')\r\n//挂载到Vue实例\r\n//无token请求\r\nVue.prototype.http = https.request\r\n//含token请求\r\nVue.prototype.https = https.requests\r\n\r\nimport Vant from 'vant';\r\n\r\nVue.use(Vant);\r\n\r\nApp.mpType = 'app'\r\n\r\nconst app = new Vue({\r\n    store,\r\n    ...App\r\n})\r\napp.$mount()3.使用//this.https 表示含Token的请求\r\n//this.http  表示不含token的请求\r\n\r\nthis.https('index/addOrder','post',src) //(请求地址,请求类型,数据)\r\n    .then(res=>{    \r\n       \r\n    })\r\n    .catch(err=>{"}
{"title": "微信小程序的「同层渲染」踩坑记 ", "author": "Rolan", "time": "2020-4-1 00:06", "content": "背景\r\n近期在开发小程序中，接触最多的就是 canvas 了，期间又因为兼容性的问题，又经历了底层 API 的新旧版的替换，踩的坑可谓令人印象深刻。小程序（微信）的 canvas 与 HTML 标准的 canvas 有较大区别，就连小程序本身的 canvas 底层 API 都有两个大版本的区别（其实远古时期还有一个版本，但年代过于久远就不做考究了）。目前现存的两个版本的区别在于是否支持「同层渲染」。\r\n同层渲染\r\n小程序的内容大多是渲染在 WebView 上的，如果把 WebView 看成单独的一层，那么由系统自带的这些原生组件则位于另一个更高的层级（如 canvas、video）。两个层级是完全独立的，因此无法简单地通过使用 z-index 控制原生组件和非原生组件之间的相对层级。想要在原生组件之上只能用 cover-view 和 cover-image 来实现。但  cover-view 和 cover-image 支持的 css 样式是在很有限，而且经过实践来看，cover-view 在安卓部分机器上性能真的很差。\r\n\r\n「同层渲染」则是将原生组件直接渲染到 WebView 层级上，就可以通过简单的 z-index 来控制层级，而且支持的 css 非常丰富，麻麻再也不用担心我碰到的层级问题了！是不是看起来很美好？然而现实非常残酷。\r\n\r\n「同层渲染」存在的问题\r\n首先，根据小程序官方的文章来看，几乎是重构了整个「原生组件」，使用方式和支持的特性与之前的区别都非常大，非常类似标准的 canvas API，甚至官方声称「支持标准 canvas 的大部分属性方法」。但是根据我的实际项目经验来看，新版 canvas API 仅仅只是在 iOS 上表现良好，在部分安卓机器上会出现许多怪异行为。一个简单的例子是绘制多个相同的形状时，画笔似乎会出现在「飘忽不定」的位置上，导致绘制最终结果无法预测。另外很让人头疼的一个地方在于 drawImage 方法上。旧版 API drawImage 第一个参数是图片路径，本地路径或网络路径皆可，但新版 API  drawImage 第一个参数必须是图片实例，由于小程序无法获取 DOM 元素，只能用官方提供的 createImage 方法创建图片实例，在其 onLoad 回调中再次调用 drawImage，才能实现原先简单的方法。诸如此类。但这些都是可以克服的，最终导致我们放弃的原因是其在部分安卓机器上的「不确定性」，如果在「新特性」和「兼容性」上做选择，我想我还是坚持选择「兼容性」吧。就好像「优雅降级」和「渐进增强」，我更倾向于后者。\r\n「兼容性」下的「同层渲染」\r\n我相信大多数做过小程序 canvas 相关都有层级的烦恼。既然无法使用新版 API 来实现，那问题总要解决，最终我们想出了一套在旧版 API 也可以实现类似「同层渲染」的效果。目前需要「同层渲染」的场景基本上都是需要在 canvas 上弹层，所以在覆盖 canvas 的时候不会同时操作 canvas，因为可以利用canvasToTempFilePath 可以临时将  canvas 转成图片，然后隐藏 canvas，显示 tempImage 即可。\r\n黎明的曙光\r\n新版 canvas API 并不是一无是处，有一个很大的变化在于它不再使用物理尺寸来绘制，使用的是实际尺寸。这就会使得使用新版 API 绘制的结果比原来高清许多，这算是为数不多的优点吧。另外新版 canvas API 在 iOS 上表现还是很不错的。希望未来官方可以让新版 canvas API 兼容性更优秀，让开发者早日摆脱这些临时方案。"}
{"title": "制作微信小程序音乐播放器踩的坑! ", "author": "Rolan", "time": "2020-3-9 00:21", "content": "ps: 搭配思维导图食用更佳!源码链接:在onload中,必须在获取云数据库的数据时给innerAudioContext.src赋默认值Page({\r\n  onLoad: function (options) {\r\n        album.get().then(res => {//获取云数据库的数据\r\n          this.setData({\r\n            albums: res.data\r\n          })\r\n          innerAudioContext.src = res.data[this.data.currentIndex].link\r\n        })\r\n        //错误innerAudioContext.src = this.data.albums[this.data.currentIndex].link \r\n        //此处console.log(this.data.albums)为[]因为album.get()是异步操作\r\n    }\r\n})\r\n复制代码解决监听音频进度更新onTimeUpdate不执行更新onTimeUpdate不触发和onWaiting有关,当拖动进度\\播放完毕\\切歌等重新加载音乐时，都会 触发onWaiting，然后onTimeUpdate就无法执行 .解决方法是:暂停音乐后再定时(延迟时间要充足!)播放innerAudioContext.pause()//暂停音乐\r\n      //音乐跳转到指定位置\r\n      innerAudioContext.seek((e.detail.value * innerAudioContext.duration) / 100)\r\n      setTimeout(() => {\r\n        innerAudioContext.play()//播放音乐\r\n      }, 500)\r\n复制代码实现图片原地旋转动画developers.weixin.qq.com/miniprogram…const innerAudioContext = wx.createInnerAudioContext()\r\nconst animation = wx.createAnimation({//创造动画\r\n  duration: 500,\r\n  timingFunction: 'linear',\r\n})\r\nthis.data.timer = setInterval(() => {//封面旋转\r\n        animation.rotate(this.data.rotate_deg).step()\r\n        this.setData({\r\n          rotate_deg: this.data.rotate_deg + 45,\r\n          animationData: animation.export()\r\n        })\r\n      }, 500)\r\n复制代码获取当前歌曲信息blog.csdn.net/qq_41183241…方法用法wx:for在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件wx:key指定列表中项目的唯一的标识符wx:key=\"字符串\"代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。wx:key=\"*this\"代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。wx:for-item指定数组当前元素的变量名wx:for-index可以指定数组当前下标的变量名data-*组件上触发的事件时，会发送给事件处理函数<block wx:for=\"{{albums}}\" wx:key=\"index\" >\r\n    <image src=\"{{item.cover}}\" class=\"item_cover\" bindtap=\"imgClick\" data-index=\"{{index}}\" wx:for-index=\"index\"></image>\r\n  </block> \r\n复制代码imgClick:function (e){\r\n    this.setData({\r\n      currentIndex: e.target.dataset.index\r\n    })\r\n    ...\r\n  },\r\n复制代码如何如何实现切割保证进度条正常更新-暂停播放(用原生的还是自制的)developers.weixin.qq.com/community/d…如何获取网易云音乐链接网易云音乐外链(其中id改为相应的歌曲ID即可): music.163.com/song/media/…实现歌曲循环播放第一首切上一首: ①当前索引 = 歌单长度; 当前索引-1最后一首切下一首: ①当前索引 = (当前索引 + 1) % 歌单长度prev_song: function(){//上一首\r\n    if (this.data.currentIndex == 0) {//判断是否是第一首歌\r\n      this.data.currentIndex = this.data.albums.length\r\n    }\r\n    this.setData({\r\n      currentIndex: this.data.currentIndex - 1\r\n    })\r\n    ...\r\n  },\r\n  next_song: function () {//下一首\r\n    var len = this.data.albums.length//歌曲列表长度\r\n    var x = (this.data.currentIndex + 1) % len//下一首歌的索引\r\n    this.setData({\r\n      currentIndex: x\r\n    })\r\n    ...\r\n  },\r\n复制代码"}
{"title": "小程序悬浮按钮，悬浮导航球 ", "author": "Rolan", "time": "2020-3-10 00:37", "content": "一个开源的悬浮按钮组件，小程序原生支持。一直很喜欢华为的导航按钮，能够完美适合大屏手机，自由停放位置，不论是左手习惯还是右手习惯，都很方便(可能我手比较小，左右上角够不着）。支持功能支持自由拖动，停放支持自定义事件(单击，双击，长按)支持自定义导航球中间的文字/图片开发难点使用wxs悬浮球的开发思路比较简单，一个view，样式 position:fixed ，支持拖动。在web开发中，我们能够比较容易实现这样的功能。要想在小程序中实现高性能的交互动画(touch类)，一定要了解如何使用页面的 wxs 这个残疾JS来操作对象(调试很麻烦，js极度残疾)<wxs module=\"tool\">\r\n  function tStart(e, ins){}\r\n  \r\n  function tMove(e, ins){\r\n    e.instance.setStyle('transform: translate3d(...)')  \r\n    // e.instance指向当前操作对象\r\n    // setStyle 设置该对象的style样式\r\n  }\r\n  \r\n  function tEnd(e, ins){}\r\n  \r\n  module.exports = {\r\n    tStart: tStart,\r\n    tMove: tMove,\r\n    tEnd: tEnd\r\n  }\r\n</wxs>\r\n\r\n<view catch:touchstart=\"{{tool.tStart}}\" catch:touchmove=\"{{tool.tMove}}\" ... />\r\n复制代码这里使用catch，而不是使用bind来绑定事件，事件指向 wxs 的方法。考虑到悬浮导航球是作为工具在其他场景中使用，为了不会污染touch事件，或者导致页面不必要的滚动。位移距离手机宽高不一致，即x轴的运动距离小于y轴运动距离(单位时间)，假定手机宽高比为1:2，x轴运动1px，y轴则运动了2px，我们可以设置一定的系数，使得拖动效果符合预期。监听事件最终的事件响应一定是在page页面(或者组件内部)实现事件监听，wxs有一套事件调用机制function tStart(e, ins){\r\n  ins.callMethod('onTouchStart', e)\r\n  // 调用当前组件/页面在逻辑层（App Service）定义的函数。funcName表示函数名称，args表示函数的参数\r\n}\r\n复制代码"}
{"title": "简单说说微信小程序的底层原理 ", "author": "Rolan", "time": "2019-11-19 00:12", "content": "小程序选择了 Hybrid 的渲染方式，将UI渲染跟 JavaScript 的脚本执行分在了两个线程。双线程模型小程序的渲染层和逻辑层分别由两个线程管理：渲染层：界面渲染相关的任务全都在\tWebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个\tWebView 线程。逻辑层：采用\tJsCore 线程运行JS脚本，在这个环境下执行的都是有关小程序业务逻辑的代码。双线程之间的通信我们都知道小程序是避免DOM操作，而是采用数据驱动来渲染页面的，那么他到底是怎么通过更改数据来更新DOM呢。逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。在渲染层会把WNML转化成Js对象，Js对象会模拟DOM树逻辑层更新数据的时候，通过setData方法将数据从逻辑层转发到Native,Native再转发到渲染层这时候，比较两虚拟DOM树的差异，最后将差异应用到真实DOM树上，更新页面。Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。小程序的生命周期小程序的生命周期借鉴了Android的生命周期，如果你了解过Android的APP开发，那么理解小程序的就会很简单。界面线程有四大状态：初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向“服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata（）函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。结束状态：结束渲染。服务线程五大状态：初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow， 然后等待界面线程的“界面线程初始化完成”信号。onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行，简单理解，这就是唯一差别。等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染。激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面。后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的。毕竟小程序的框架刚推出，应该后续会有很大不同吧。运行机制启动热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用\twx.getUpdateManager 做个检查更新的功能。"}
{"title": "Taro+react自定义导航条/Tabbar菜单 ", "author": "Rolan", "time": "2019-11-27 00:38", "content": "基于taro自定义导航栏Navbar|仿微信顶部导航|taro自定义tabbar这几天研究taro发现，官网提供的都是H5、小程序案例，至于RN案例甚少。恰好之前有过react及react-native项目经验，经过一番探究，终于实现能编译到多端，不过采坑不少，尤其是在RN环境下的样式问题。react仿微信web版聊天室： blog.csdn.net/yanxinyun19…如下图：在H5/小程序/RN效果均测试通过项目中用到的图标都是阿里iconfont字体图标，下载好后将fonts文件夹拷贝到项目目录下。import './styles/fonts/iconfont.scss' 在h5、小程序下 这种写法即可： <Text className=\"iconfont icon-back\"></Text>不过为了兼容RN，只能通过Unicode方式这样写： <Text className=\"iconfont\">&#xe84c;</Text>如果是通过变量传递： let back = '\\ue84c' <Text>{back}</Text>Taro自定义导航栏在App.js配置navigationStyle，将设置为custom，就可以自定义导航栏class App extends Component {\r\n    config = {\r\n        pages: \r\n            'pages/index/index',\r\n            ...\r\n        ],\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#fff',\r\n            navigationBarTitleText: 'Taro',\r\n            navigationBarTextStyle: 'black',\r\n            navigationStyle: 'custom'\r\n        },\r\n        ...\r\n    }\r\n    \r\n    ...\r\n}\r\n复制代码components目录下新建导航栏Navbar组件/*\r\n * @desc   Taro自定义导航条navbar组件\r\n * @about  Q：282310962  wx：xy190310\r\n */\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { View, Text, Input, Image } from '@tarojs/components'\r\nimport classNames from \"classnames\";\r\nimport './index.scss'\r\n \r\nexport default class NavBar extends Taro.Component {\r\n    // 默认配置\r\n    static defaultProps = {\r\n        isBack: false,\r\n        leftIcon: '\\ue84c',\r\n        title: ' ',\r\n        background: '#6190e8',\r\n        color: '#fff',\r\n        center: false,\r\n        search: false,\r\n        searchStyle: '',\r\n        fixed: false,\r\n        headerRight: [],\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            searchText: '',\r\n        }\r\n    }\r\n\t\r\n\t...\r\n \r\n    render() {\r\n        const { isBack, leftIcon, title, background, color, center, search, searchStyle, fixed, height, headerRight } = this.props\r\n        const { searchText } = this.state\r\n        \r\n        let weapp = false\r\n        if (process.env.TARO_ENV === 'weapp') {\r\n            weapp = true\r\n        }\r\n \r\n        return (\r\n            <View className={classNames('taro__navbar', fixed && 'taro__navbar--fixed', fixed && weapp && 'taro__navbar-weapp--fixed')}>\r\n                <View className={classNames('taro__navbar-wrap', fixed && 'taro__navbar-wrap--fixed', weapp && 'taro__navbar-wrap__weapp')} style={{backgroundColor: background}}>\r\n                    {/* 返回 */}\r\n                    <View className={classNames('taro__navbar-left__view', isBack && 'taro__navbar-left__view--isback')}>\r\n                    {isBack &&\r\n                        <TouchView activeOpacity={.5} onClick={this.handleNavigateBack}>\r\n                            <View className=\"taro__navbar-icon__item\"><Text className=\"iconfont taro__navbar-iconfont\" style={{color: color}}>{leftIcon}</Text></View>\r\n                        </TouchView>\r\n                    }\r\n                    </View>\r\n                    \r\n                    {/* 标题 */}\r\n                    {!search && center && !weapp ? <View className=\"flex1\" /> : null}\r\n                    {search ? \r\n                    (\r\n                        <View className=\"taro__navbar-search flex1\">\r\n                            <Input className=\"taro__navbar-search__input\" placeholder=\"搜索...\" onInput={this.updateInputText} style={{color: color, ...searchStyle}} />\r\n                        </View>\r\n                    )\r\n                    :\r\n                    (\r\n                        <View className={classNames('taro__navbar-title flex1', center && !weapp && 'taro__navbar-title--center')}>\r\n                            {title && <Text className=\"taro__navbar-title__text\" style={{color: color}}>{title}</Text>}\r\n                        </View>\r\n                    )\r\n                    }\r\n \r\n                    {/* 右侧 */}\r\n                    <View className=\"taro__navbar-right__view\">\r\n                    {headerRight.map((item, index) => (\r\n                        <TouchView activeOpacity={.5} key={index} onClick={()=>item.onClick && item.onClick(searchText)}>\r\n                            <View className=\"taro__navbar-icon__item\">\r\n                                {item.icon && <Text className=\"iconfont taro__navbar-iconfont\" style={{color: color, ...item.style}}>{item.icon}</Text>}\r\n                                {item.text && <Text className=\"taro__navbar-iconfont__text\" style={{color: color, ...item.style}}>{item.text}</Text>}\r\n                                {item.img && <Image className=\"taro__navbar-iconfont__img\" src={item.img} mode='aspectFit' />}\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__navbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__navbar-badge--dot\"></Text>}\r\n                            </View>\r\n                        </TouchView>\r\n                    ))\r\n                    }\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码在页面引入组件即可： import NavBar from '@components/navbar'支持自定义背景、颜色、左侧图标、标题居中、搜索框，右侧按钮支持图标/文字/图片，还可以设置样式，红点提示、事件处理<NavBar title='Taro标题栏' fixed\r\n    headerRight={[\r\n        {icon: '\\ue614', style: {color: '#e93b3d'}},\r\n        {img: require('../../assets/taro.png'), dot: true, onClick: this.handleCallback},\r\n        {icon: '\\ue600', style: {marginRight: 10}},\r\n    ]} \r\n/>复制代码<NavBar isBack leftIcon={'\\ue69f'} title='搜索栏' background='#42b983' color='#fcc' search\r\n    searchStyle={{\r\n        backgroundColor:'rgba(255,255,255,.6)', borderRadius: Taro.pxTransform(50), color: '#333'\r\n    }}\r\n    headerRight={[\r\n        {icon: '\\ue622', style: {color: '#6afff9'}},\r\n        {icon: '\\ue63a'},\r\n    ]} \r\n/>复制代码Taro自定义底部Tabbarimport Taro from '@tarojs/taro'\r\nimport { View, Text } from '@tarojs/components'\r\nimport classNames from 'classnames'\r\nimport './index.scss'\r\n \r\nexport default class TabBar extends Taro.Component {\r\n    // 默认参数配置\r\n    static defaultProps = {\r\n        current: 0,\r\n        background: '#fff',\r\n        color: '#999',\r\n        tintColor: '#6190e8',\r\n        fixed: false,\r\n        onClick: () => {},\r\n        tabList: []\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            updateCurrent: props.current\r\n        }\r\n    }\r\n    ...\r\n \r\n    render() {\r\n        const { background, color, tintColor, fixed } = this.props\r\n        const { updateCurrent } = this.state\r\n        \r\n        return (\r\n            <View className={classNames('taro__tabbar', fixed && 'taro__tabbar--fixed')}>\r\n                <View className={classNames('taro__tabbar-list', fixed && 'taro__tabbar-list--fixed')} style={{backgroundColor: background}}>\r\n                    {this.props.tabList.map((item, index) => (\r\n                        <View className=\"taro__tabbar-item taro__tabbar-item--active\" key={index} onClick={this.updateTabbar.bind(this, index)}>\r\n                            <View className=\"taro__tabbar-icon\">\r\n                                <Text className=\"iconfont taro__tabbar-iconfont\" style={{color: updateCurrent == index ? tintColor : color}}>{item.icon}</Text>\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__tabbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__tabbar-badge--dot\"></Text>}\r\n                            </View>\r\n                            <Text className=\"taro__tabbar-title\" style={{color: updateCurrent == index ? tintColor : color}}>{item.title}</Text>\r\n                        </View>\r\n                    ))}\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码自定义tabbar也支持自定义背景、颜色、图标，点击选项事件返回索引值<TabBar current={currentTabIndex} background='#f8f8f8' color='#999' tintColor='#6190e8' fixed onClick={this.handleTabbar}\r\n    tabList={[\r\n        {icon: '\\ue627', title: '首页', badge: 8},\r\n        {icon: '\\ue61e', title: '商品'},\r\n        {icon: '\\ue605', title: '个人中心', dot: true},\r\n    ]}\r\n/>\r\n复制代码好了，今天就介绍到这里，后续会考虑使用Taro技术开发个多端实战项目。ReactNative聊天APP实战|仿微信聊天/朋友圈/红包界面"}
{"title": "小程序同构方案 kbone 分析与适配 ", "author": "Rolan", "time": "2019-12-4 00:23", "content": "在微信小程序的开发的过程中，我们会存在小程序和 H5 页面共存的场景，而让小程序原生和 web h5 独立开发，往往会遇到需要两套人力去维护。对开发者而言，加大了工作量成本，对于产品而言，容易出现展示形态同步不及时问题。在这种情况下，我们急需要找到一个既能平衡性能，也能满足快速迭代的方案。主流的小程序同构方案web-view 组件webview 组件是一个承载网页的容器，最简单的方案就是使用原 h5 的代码，通过 web-view 组件进行展示。其优点是业务逻辑无需额外开发与适配，只需要处理小程序特有的逻辑，然后通过 jssdk 与原生小程序通讯。使用 webview 加载 h5 的问题也非常明显，首先是体验问题，用户见到页面会经过以下环节：加载小程序包，初始化小程序，再加载 webview 中的 html 页面，然后加载相关资源，渲染 h5 页面，最后进行展示。最终导致的结果是打开体验非常差。另外其他缺点是小程序对 web-view 部分特性有限制，比如组件会自动铺满整个小程序页面，不支持自定义导航效果等。静态编译兼容静态编译是最为主流的小程序同构方案，类似的有 taro, mpvue 等。其思路是在构建打包过程，把一种结构化语言，转换成另一种结构化语言。比如，taro 把 jsx 在构建时进行词法分析，解析代码获取 AST，然后将 AST 递归遍历生成 wxml 目标代码。静态编译的好处是非常明显，一套代码，通过编译分别转 h5 和小程序，兼具性能与跨平台。另一方面，随着这种方案的流行，大家也感受到了其明显的问题，首先，由于小程序本身的限制，比如无法 dom 操作，js 与 webview 双线程通信等，导致静态编译语法转换，不能做到彻底的兼容，开发体验受制于框架本身的支持程度，相信踩过坑的同学应该非常有痛的感悟。其次，静态编译转换逻辑需要与小程序最新的特性保持同步，不断升级。小程序运行时兼容方案静态编译的方案实现了同构，但它只是以一种中间态的结构化语法去编码，非真正的 web，牺牲了大量的灵活性。另外一种更灵活的方案，运行时兼容应值得去尝试。小程序原理我们回到小程序本身的限制上来。由于小程序采用双线程机制，内部通过一个 webview 用于承载页面渲染，但小程序屏蔽了它原本的 DOM/BOM 接口，自己定义了一套组件规范；另一方面，使用独立的 js-core 负责对 javascript 代码进行解析，让页面和 js-core 之间进行相互通信（setData），从而达到执行与渲染的分离。而浏览器的 DOM 接口是大量 web 得以显示的底层依赖，这也是 h5 代码无法直接在小程序中运行的主要原因。那么如何突破小程序对接口 DOM 的屏蔽呢？ 最直接的思路就是用 JS 实现和仿造一层浏览器环境的 DOM 相关的标准接口，让用户的 JS 代码可以无感知的自由操作 DOM。通过仿造的底层 DOM 接口，web 代码执行完后，最终生成一层仿造的 DOM 树，然后讲这棵 DOM 树转换成小程序的 wxml 构成的 DOM 树，最后由小程序原生去负责正确的渲染出来。kbonekbone 是微信官方出一套小程序运行时兼容方案，目前已经接入的小程序有小程序官方社区，及腾讯课堂新人礼包等。并且有专人维护，反馈及时。kbone 方案核心主要有两大模块，第一是 miniprogram-render 实现了对浏览器环境下 dom/bom 的仿造，构建 dom 树，及模拟 web 事件机制。第二个模块是 miniprogram-element 是原生小程序渲染入口，主要监听仿造 dom 树的变化，生成对应的小程序的 dom 树，另外一个功能是监听原生小程序事件，派发到仿造的事件中心处理。DOM/BOM 仿造层DOM、BOM 相关的接口模拟，主要是按照 web 标准构建 widow、document、node 节点等相关 api，思路比较清晰，我们简单看下其流程。首先在用户层有一个配置文件 miniprogram.config，里面有必要信息 origin、entry 等需要配置。在 miniprogram-render 的入口文件 createPage 方法中，配置会初始化到一个全局 cache 对象中，然后根据配置初始化 Window 和 Document 这两个重要的对象。Location、Navigator、Screen、History 等 BOM 实例都是在 window 初始化过程中完成。DOM 节点相关 api 都是在 Document 类中初始化。所有生成的节点和对象都会通过全局的 pageMap 管理，在各个流程中都能获取到。小程序渲染层miniprogram-element 负责监听仿造 DOM 仿造的变化，然后生成对应小程序组件。由于小程序中提供的组件和 web 标准并不完全一样，而我们通过 html 生成的 dom 树结构千差万别，如和保证任意的 html dom 树可以映射到小程序渲染的 dom 树上呢？kbone 通过小程序自定义组件去做了这件事情。简单说下什么是自定义组件，既将特定的代码抽象成一个模块，可以组装和复用。以 react 为例，div、span 等标签是原生组件，通过 react.Component 将 div 和 span 组合成一个特定的 react 组件，在小程序中用自带的 view、image 等标签通过 Component 写法就能组合成小程序自定义组件。和大部分 web 框架的自定义组件类似，小程序自定义组件也能够自己递归地调用自己，通过将伪造的 dom 结构数据传给自定义组件作为子组件，然后再递归的调用，直到没有子节点为止，这样就完成了一个小程序 dom 树的生成。性能问题多层 dom 组合大量小程序自定义组件会有额外的性能损耗，kbone 在实现时提供了一些优化。其中最基本的一个优化是将多层小程序原生标签作为一个自定义组件。dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。以上逻辑就是通过 DOM_SUB_TREE_LEVEL 层级数对节点过滤，更新后，检测是否还有节点，再触发更新。节点缓存在页面 onUnload 卸载的过程中，kbone 会将当前节点放入缓存池中，方便下次初始化的时候优先从缓存中读取。kbone 接入与适配kbone 作为一种运行时兼容方案，适配成本相对于静态编译方案而言会低很多，总体来说对原代码侵入性非常少，目前接入过程比较顺利（期间遇到的坑，感谢 作者 june 第一时间帮忙更新发布 [玫瑰]）svg 资源适配小程序不支持 svg，对于使用 svg 标签作为图片资源的应用而言，需要从底层适配。在一开始我们想到的方案有通过 肝王的 cax 进行兼容，但评估后不太靠谱，cax 通过 解析 svg 绘制成 canvas，大量 icon 会面临比较严重的性能问题。那么最直接暴力的办法就是使用 webpack 构建过程直接把 svg 转 png？后面一位给力的小伙伴想到通过把 svg 标签转成 Data URI 作为背景图显示，最终实践验证非常可靠，具体可以参考 kbone svg 适配。网络层适配/cookie微信小程序环境拥有自己定义的一套 wx.request API， web 中的 XMLHttpRequest 对象是无法直接使用。由于我们代码中使用了 axios，所以在预言阶段直接简单通过 axios-miniprogram-adapter 进行适配器，后面发现部分业务没有使用 axios，兼容并不够彻底。于是直接从底层构建了一个 XMLHttpRequest 模块，将 web 网络请求适配到 wx.request。同时做了 cookie 的自动存取逻辑适配（小程序网络请求默认不带 cookie）。这一层等完善好了看是否能 pull request 到 kbone 代码仓库中。差异性 DOM/BOM API 适配部分 web 中的接口在小程序无法完全获得模拟，比如 getBoundingClientRect 在小程序中只能通过异步的方式实现。类似的有 removeProperty、stopImmediatePropagation等接口在 kbone 中没有实现，performance 等 web 特有的全局变量的需要兼容。这些扩展 API 可以通过 kbone 对外暴露的 dom/bom 扩展 API 进行兼容。getBoundingClientRect对于元素的的高度 height \\offsetHeight 获取，我们只能通过 $getBoundingClientRect 异步接口，如果是 body scroll-view 实现的，getBoundingClientRect 返回的是 scrollHeight。滚动web 的全局滚动事件默认是无法触发，需要通过配置 windowScroll 来监听，启用这个特性会影响性能。global: {\r\n    windowScroll: true\r\n},\r\n样式适配标签选择器kbone 样式有一个坑，就是它会将标签选择器转换成类选择器去适配小程序环境，比如span { } =>  .h5-span{  }\r\n这样带来的副作用就是选择器的权重会被自动提升，对选择器权重依赖的标签样式需要去手动调整兼容。其他适配点注意使用标准的 style 属性，比如有 webkit-transform 会不支持，及小程序样式和 web 差异性兼容等。  style: {\r\n      'WebkitTransform': 'translate(' + x + 'px, 0)' // 正确\r\n     // '-webkit-transform': 'translate(' + x + 'px, 0)' 报错\r\n  }\r\n路由适配在初始化路由阶段，曾经遇到过 Redux 更新 dom 后偶现节点销毁，最终定位到是 kbone 对 Location 等 BOM 实例化过晚，最终在 june 帮忙及时调整了顺序，更新了一个版本，现最新本所有 BOM 对象会在业务执行前准备好。//初始化dom\r\nthis.window.$$miniprogram.init()\r\n...\r\n//初始化业务\r\ninit(this.window, this.document)\r\n隐式全局变量兼容在模拟 XMLHttpRequest 模块的过程中遇到一个问题，什么时候初始化这个对象，我们可以选择在网络请求库初始化前引入它，挂载在仿造的 window 对象下。但仍然会出现一个问题，第三放库直接使用的是 XMLHttpRequest 对象，而非通过 window 访问。var request = new XMLHttpRequest() // 报错\r\n \r\nvar request = new window.XMLHttpRequest() // 正确\r\n在正常的 web 环境，window 是默认的顶层作用域，而小程序中隐式的使用 window 对象则会报错。为了解决这一问题，可以通过配置文件的 globalVars 字段，将 XMLHttpRequest 直接进行定义。 globalVars: [\r\n    ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\")']\r\n]\r\n构建的过程中会在所有依赖前转成如下代码 ： var XMLHttpRequest = require(\"libs/xmlhttprequest.js\")\r\n这样做解决了隐式访问 window 作用域问题。但又面临另一个问题，那就是 xmlhttprequest 模块本身内部由依赖仿造 window 对象，比如 cookie 访问，而此时因为 require 的模块独立的作用域无法访问到其他模块的仿造 window 对象。于是最终通过导入一个 function 传入 window 作用域，然后初始化 xmlhttprequest。  globalVars: [\r\n      ['XMLHttpRequest', 'require(\"libs/xmlhttprequest.js\").init(window, document)']\r\n]\r\n多端构建小程序和 web 端需要的资源及部分逻辑是有差异，通过 webpck 配置进行差异化处理，具体可以参考文档编写 kbone webpack 配置。大概是这样的区分跨端配置：分离打包入口文件:小程序打包入口依赖的 dom 节点，需要主动创建。详细示例参照官方 demo.export default function createApp() {\r\n    initialize(function() {\r\n        let Root = require('./root/index').default;\r\n \r\n        const container = document.createElement('div')\r\n        container.id = 'pages';\r\n        document.body.appendChild(container);\r\n        render(<Root />, container)\r\n    })\r\n}\r\n由于小程序本身是没有真正 userAgent，kbone 内部是是根据当前环境进行仿造。//miniprogram-render/src/bom/navigator#45\r\nthis.$_userAgent = `${this.appCodeName}/${appVersion} (${platformContext}) AppleWebKit/${appleWebKitVersion} (KHTML, like Gecko) Mobile MicroMessenger/${this.$_wxVersion} Language/${this.language}`\r\n在业务中有需要区分小程序平台的场景，我们可以通过 webpack DefinePlugin 插件进行注入，然后通过定义变量进行判断。if (!process.env.isWxMiniProgram) {\r\n    render(\r\n        <Root />,\r\n        document.getElementById('pages')\r\n    );\r\n}\r\n小程序分包在腾讯文档的小程序中，有一个独立的小程序仓库。 而文档管理列表是另外一个独立的 H5 项目，嵌入到小程序 webview 动态加载。通过 kbone 转原生打包后，这部分代码需要继承到小程序仓库中。首先我们可以通过脚本，在 webpack 构建过程，将 kbone 编译后的包 copy 到独立小程序仓库的目录下，合并小程序相关配置，从而实现功能合并。这样遇到的一个问题是主包大小超过限制，通过小程序分包我们可以解决这个问题，将原小程序非首屏页面全部放分包之中，配置 preloadRule 字段再预加载分包。\"subpackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\r\n        \"pages/cat\"      ]\r\n    }\r\n  ]\r\n  \"preloadRule\": {\r\n    \"pages/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\"important\"]\r\n    }  \r\n}\r\n结通过对目前各种小程序同构方案的对比与实践，kbone 是一种非常值得推荐的新思路，新方法，兼具性能与灵活。唯一不足的地方就是目前仍有不少底层工作需要适配，更多的问题在继续探索中，相信随着不断迭代及采坑后的反馈，kbone 会变得越来稳定和成熟"}
{"title": "小程序 input 使用setData触发bindinput事件 ", "author": "Rolan", "time": "2019-12-17 00:33", "content": "背景\r\nUI设计如下图\r\n\r\n当有输入内容后显示后面的清除按钮，点击清除删除input里的内容\r\n代码实现\r\n我的代码实现是监听bindinput事件，将输入框中的值this.setData({inputValue}), 清除按钮监听点击事件，触发后this.setData({inputValue: ''})\r\n问题\r\nandroid手机上存在一个问题，当input组件是focus状态时，点击清除按钮输入框会闪一下，键盘保持弹出状态，输入框中的内容并没有删除，再次点击后才能删除， 开发者工具和ios均没有上述问题\r\n解决\r\n我发现出现上面的问题是因为在点击清除按钮时额外的触发了一次bindinput事件，将输入框中的值又重新赋值给inputValue了，我一开始以为，额外触发bindinput事件是因为input失焦导致的，但是后面又发现我点击空白的地方并不会触发bindinput事件\r\n后来我发现是setData导致的，找到了原因就可以对症下药了，查看开发文档发现bindinput的返回值中有一个keyCode属性，这个属性只有在键盘输入的时候才会有，用于记录输入的键值，所以我在bindinput中加了一层判断，如果有keyCode这个属性才会进行后面的运算。\r\n缺陷\r\n在开发者工具中使用键盘输入bindinput的返回值中并没有keyCode这个属性，所以在调试时就会存在输入的值并不会赋值给inputValue,需要注释对keyCode的判断。\r\n疑问\r\n上面的问题只会在input组件是focus状态时才会出现，如果一开始不是focus时直接点击清除按钮并不会出现上述问题，所以这个bug可能还和同时监听bindinput和bindblur或者bindfocus有关，这个有待后面进行验证。"}
{"title": "小程序中解决网络请求缓存 ", "author": "Rolan", "time": "2019-12-30 00:45", "content": "需求\r\n提交小程序审核时，有一个体验测评，产品让我们根据小程序的体验测评报告去优化小程序。\r\n其中有一项是网络请求的优化，给我们出了很大的难题。\r\n文档中是这样解释的：3分钟以内同一个url请求不出现两次回包大于128KB且一模一样的内容\r\n看到这个问题的时候，首先想到的是在响应头上加上cache-control，经过测试发现小程序并不支持网路请求缓存。搜索发现官方明确答复，小程序不支持网络请求缓存：wx.request不支持http缓存\r\n既然官方不支持网络请求缓存，那只能自己想办法解决这个问题了。\r\n先来看一下需求：3分钟内，同一请求只能请求一次。\r\n分析\r\n分析：\r\n\r\n只需做GET请求的网络缓存。\r\n缓存时间如何控制。\r\n做了缓存之后，如何知道3分钟，这个请求在服务端数据有没更新。\r\n提交GET请求前，先检查本地有没有缓存\r\n\r\n前两点比较好实现，虽然小程序不支持网络请求缓存，但我们还是可以利用cache-control来实现这个功能。\r\n首先网络请求需不需要情缓存统一交给服务端去做，服务端在处理GET请求时，统一加上响应头cache-control，如果需要缓存就用max-age=180，如果不需要做网络请求就用no-cache。前端根据响应头信息自己做前端缓存。\r\n其中的难点是前端如何知道服务端数据有没更新，如果服务端数据更新了，前端还是使用缓存这是有问题的。\r\n经过一番思考后发现，前端提交数据后，相应的GET请求数据会更新，也就是说前端只要有数据提交，就应该把缓存清空。\r\n这有一个难点，当前端提交数据时，前端是不知道哪些GET请求会因此更新数据，所以这个问题我们没有解决，我的方法比较粗暴：只要前端提交了数据，就将所有缓存清空。这是一个治标不治本的问题。\r\n实现\r\n公司项目封装了HTTP请求\r\n\r\n拦截请求，如果是GET请求，检查缓存，\r\n\r\n如果缓存没过期，将缓存返回出去，不再发请求\r\n如果缓存过期，发请求\r\n\r\n\r\n\r\nif (request.method.toLowerCase() === \"get\"){\r\n  // param 请求信息\r\n  const cache = this.handleCatchControl(request)\r\n  if (!cache.isRequest)\r\n    return this.listener.onApiResponse(request, 200, cache.data), sequence;   //将缓存返回给对应的请求\r\n}\r\n复制代码\r\n缓存网络请求\r\n\r\n// param 响应头，上下文，响应数据\r\nthis.setCatchControl(headers, context, response.data)\r\n复制代码\r\n两个工具函数\r\n\r\n处理网络缓存\r\n设置网络缓存\r\n\r\n\r\n\r\n\r\n设置网络请求\r\n\r\nGET请求缓存数据，其他请求清空数据\r\n数据格式：\r\n\r\n//如果同时发起多个`GET`请求，需要拼接之前缓存数据\r\nApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n  [context.request.url]: {    //api\r\n    data,   //响应数据\r\n    expireTime: Number(cacheControl.split(\"=\")[1] + '000'),   //过期时间\r\n    cacheTime: new Date().getTime(),    //缓存时间\r\n  }\r\n})\r\n复制代码\r\n\r\n// param 响应头，上下文，响应数据\r\nsetCatchControl(responseHeader: any, context: any, data: any) {\r\n  if (context.request.method.toLowerCase() === \"get\") {\r\n    const headers = HandleHeaders.get(responseHeader)\r\n    const cacheControl = headers[\"cache-control\"]\r\n    if (cacheControl && cacheControl !== \"no-cache\") {\r\n      ApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n        [context.request.url]: {\r\n          data,\r\n          expireTime: Number(cacheControl.split(\"=\")[1] + '000'),\r\n          cacheTime: new Date().getTime(),\r\n        }\r\n      })\r\n    }\r\n  } else {\r\n    ApiAgent.cacheData = {}\r\n  }\r\n}\r\n复制代码\r\n处理网络缓存\r\n\r\n判断缓存是否存在\r\n判断缓存有没过期，在设置缓存时，比对当前时间和缓存时间，是否小于失效时间\r\n\r\n\r\n\r\n// param 请求信息\r\nhandleCatchControl(request): any {\r\n  const cacheArr = ApiAgent.cacheData\r\n  if (Object.keys(cacheArr).length === 0)\r\n    return { isRequest: true }\r\n  let cache = {}\r\n  Object.keys(cacheArr).forEach(cacheArrKey => {\r\n    if (cacheArrKey === request.url) {\r\n      cache = cacheArr[cacheArrKey]\r\n    }\r\n  })\r\n  const newDate = new Date().getTime()\r\n  if (newDate - cache.cacheTime < expireTime){\r\n    return { isRequest: false, data: cache.data }\r\n  }\r\n  return { isRequest: true}\r\n}\r\n复制代码\r\n响应头全部变成小写，在小程序中，无法确定响应头的大小写会导致报错，所以统一处理响应头\r\n\r\nclass HandleHeaders {\r\n  static get(headers: { [key: string]: string }) {\r\n    const headersData: any = {}\r\n    Object.keys(headers).forEach(key => {\r\n      headersData[key.toLowerCase()] = headers[key]\r\n    })\r\n    return headersData\r\n  }\r\n}\r\n复制代码总结\r\n有一点没有说，就是这个缓存是保存在哪里的？\r\n既没有用localStorage，也没有用globalapp，用的是类的静态属性。\r\n这样做有3个好处：\r\n\r\n使用localStorage数据不好清除，后期可维护性也较差\r\n缓存挂在globalapp和请求无直接联系\r\n无需在退出小程序时手动清理缓存\r\n\r\n我在使用时遇到一个坑，是因为自己没有理解：类能保存数据的，不能保存状态，但类的对象是既可以保存数据，也可以保存状态的。\r\n最后，此方法还是有很大的优化空间。\r\n另外可添加微信ttxbg180218交流"}
{"title": "开发小程序折叠面板 ", "author": "Rolan", "time": "2020-2-16 00:41", "content": "参考了一系列的小程序UI库。。。，最后参考了ant-design的折叠面板(collapse)组件设计，功能大致如下支持默认展开动态设置标签栏动态设置内容支持无效状态支持切换响应方法戳源码构思折叠面板组件由列表组件(ui-list)实现，列表项作为标签页，列表项子元素 content 作为弹出层，数据子项结构大致如下{\r\n    title: '标签标题',\r\n    content: '弹层内容'\r\n}\r\n复制代码列表组件构建一个动态组件 ui-list ，通过配置文件实现列表结构，将如下这段数据结构const mockData = [\r\n  {title: '列表项1', content: '弹层内容1'},\r\n  {title: '列表项2', content: '弹层内容2'},\r\n  {title: '列表项3', content: '弹层内容3'},\r\n]\r\n复制代码生成大致如下的wxml<view class=\"list-container\">\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项1</view>\r\n      <view class=\"content\">弹层内容1</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项2</view>\r\n      <view class=\"content\">弹层内容2</view>\r\n    </view>\r\n    <view class=\"item\">\r\n      <view class=\"title\">列表项3</view>\r\n      <view class=\"content\">弹层内容3</view>\r\n    </view>\r\n</view>\r\n复制代码通过css样式，将弹层内容 <view class=\"content\"> 隐藏交互设计弹出设计<view class='title'> 作为展示标签，也作为点击事件的主体，当点击标签时为 <view class='item'> 的子容器添加 active 激活样式，此时弹层内容通过样式设计为 display: block 状态，即实现弹出显示<view class=\"item active\">\r\n  <view class=\"title\" bind:tap=\"change\">列表项1</view>\r\n  <view class=\"content\">弹层内容1</view> <!--css display block-->\r\n</view>\r\n复制代码更新设计为标签点击时提供 changeTitle，changeContent 方法，通过关键字段寻址，并更新数据，从而更新wxml结构，如下列的思路<view class=\"title\" bind:tap=\"change\" data-index=\"1\">列表项1</view>\r\n复制代码change(e){\r\n  const ds = e...dataset\r\n  this.toggleActive(e)\r\n  this.changeTitle(ds, ...) // 或者 this.changeContent(e, ...)\r\n}\r\nchangeTitle(ds, param) {\r\n  let index = ds.index\r\n  let $data = findIt(index)\r\n  $data.title = param\r\n  this.setData({config.data[index]: ....})\r\n}\r\nchangeContent(ds, param) {\r\n  // 思路同changeTitle\r\n}\r\n复制代码上面所述是简化逻辑，实现起来并不如此简单，尤其是寻址逻辑和更新逻辑实现及应用wxml<ui-list wx:if=\"{{collapsConfig}}\" list=\"{{collapsConfig}}\" />\r\n复制代码jslet config = {\r\n  listClass: 'collapse-pad',\r\n  data: [],\r\n  tap: function(param){ // 切换响应方法，样式操作封装在组件内部   \r\n    // this.title({...})  \r\n    // this.content({...}) \r\n    // this.disabled(true|false)\r\n  }  \r\n}\r\n\r\nPage({\r\n  data: {\r\n    collapsConfig: config \r\n  }\r\n})\r\n复制代码关于动态标签的一点想法动态标签的好处是可以将逻辑、寻址等在JS部分来实现，相较于 template 语法，动态标签的方式灵活太多了，能方便的实现组件化、模块化，规范化，和将公共部分抽离，且易于维护。当一个项目有多人维护时，碎片模板是一个地狱。"}
{"title": "微信小程序 动态加载swiper时不显示的问题（爬坑） ", "author": "Rolan", "time": "2020-1-13 00:24", "content": "问题一报错信息TypeError: Cannot read property '$$' of undefined\r\n    at HTMLElement._attached.wx.getPlatform._touchstartHandlerForDevtools解决方法：因为小程序会保留上一次滑动swiper时候的current，所以会出现上次滑动到的current在这次的数据中不存在问题，所以，每次动态加载swiper-item前，需要设置swiper的current属性为0问题二swiper 的current每次设置了0，但是还是不显示 swiper，检查元素是存在的，并且current = -1<swiper current='-1'><swiper>解决方法，动态设置swiper-item的数据时，还需设置current = 0，并且current和swiperList不能在一个this.setData中设置，要先setData swiperList 然后在setData current我是这样写的：this.setData({\r\n  swiperItem: list\r\n},()=>{\r\n  this.setData({\r\n    current: 0\r\n  })\r\n})\r\n//在每次给swiper赋值之后在它的回调中在赋值current之后没有问题成功解决，希望对你有所帮助。"}
{"title": "Taro 小程序开发大型实战：尝鲜微信小程序云 ", "author": "Rolan", "time": "2020-2-19 00:37", "content": "欢迎继续阅读《Taro 小程序开发大型实战》系列，前情回顾：熟悉的 React，熟悉的 Hooks ：我们用 React 和 Hooks 实现了一个非常简单的添加帖子的原型多页面跳转和 Taro UI 组件库 ：我们用 Taro 自带的路由功能实现了多页面跳转，并用 Taro UI 组件库升级了应用界面实现微信和支付宝多端登录 ：实现了微信、支付宝以及普通登录和退出登录Hooks + Redux 双剑合璧 ：使用了 Hooks 版的 Redux 来重构应用的状态管理使用 Hooks 版的 Redux 实现大型应用状态管理（上篇） ：使用 Hooks 版的 Redux 实现了 user 逻辑的状态管理重构使用 Hooks 版的 Redux 实现大型应用状态管理（下篇） ：使用 Hooks 版的 Redux 实现了 post 逻辑的状态管理重构Taro 小程序开发大型实战（六）：尝鲜微信小程序云（上篇） ： user 逻辑接入微信小程序云在上一篇文章中，我们将我们两大逻辑之一 User 部分接入了 Redux 异步处理流程，接着接入了微信小程序云，使得 User 逻辑可以在云端永久保存，好不自在：），两兄弟一个得了好处，另外一个不能干瞪眼对吧？在这一篇教程中，我们想办法把 User 另外一个兄弟 Post 捞上来，也把 Redux 异步流程和微信小程序给它整上，这样就齐活了:laughing:。我们首先来看一看最终的完成效果：如果你不熟悉 Redux，推荐阅读我们的《Redux 包教包会》系列教程：Redux 包教包会（一）：解救 React 状态危机Redux 包教包会（二）：趁热打铁，完全重构Redux 包教包会（三）：各司其职，重拾初心如果你希望直接从这一步开始，请运行以下命令：git clone -b miniprogram-start https://github.com/tuture-dev/ultra-club.git\r\ncd ultra-club\r\n复制代码本文所涉及的源代码都放在了 Github 上，如果您觉得我们写得还不错，希望您能给 :heart:这篇文章点赞+Github仓库加星❤ ️哦~此教程属于 React 前端工程师学习路线 的一部分，欢迎来 Star 一波，鼓励我们继续创作出更好的教程，持续更新中~“六脉神剑” 搞定 createPost 异步逻辑不知道看到这里的读者有没有发现上篇文章其实打造了一套讲解模式，即按照如下的 “六步流程” 来讲解，我们也称为 “六脉神剑” 讲解法：sagas\r\nsagas\r\nsagas\r\nreducers\r\n可以看到我们上面的讲解顺序实际上是按照前端数据流的流动来进行的，我们对标上面的讲解逻辑来看一下前端数据流是如何流动的：从组件中通过对应的常量发起异步请求sagas 监听到对应的异步请求，开始处理流程在 sagas 调用对应的前端 API 文件向微信小程序云发起请求微信小程序云函数处理对应的 API 请求，返回数据sagas 中获取到对应的数据， dispatch action 到对应的 reducers 处理逻辑reducers 接收数据，开始更新本地 Redux Store 中的 state组件中重新渲染好的，了解了讲解逻辑和对应前端数据流动逻辑之后，我们马上来实践这套逻辑，把 User 逻辑的好兄弟 Post 逻辑搞定。第一剑： PostForm 组件中发起异步请求首先从创建帖子逻辑动刀子，我们将创建帖子接入异步逻辑并接通小程序云，让文章上云。打开 src/components/PostForm/index.jsx ，对其中的内容作出对应的修改如下：import { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport './index.scss'\r\nimport { CREATE_POST } from '../../constants'\r\n\r\nexport default function PostForm() {\r\n  const [formTitle, setFormTitle] = useState('')\r\n  const [formContent, setFormContent] = useState('')\r\n\r\n  const userId = useSelector(state => state.user.userId)\r\n\r\n  const dispatch = useDispatch()\r\n...    }\r\n\r\n    dispatch({\r\n      type: CREATE_POST,\r\n      payload: {\r\n        postData: {\r\n          title: formTitle,\r\n          content: formContent,\r\n        },\r\n        userId,\r\n      },\r\n    })\r\n\r\n    setFormTitle('')\r\n    setFormContent('')\r\n  }\r\n\r\n  return (\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们现在是接收用户的文章输入数据然后向小程序云发起创建文章的请求，所以我们将之前的 dispatch SET_POSTS Action 改为 CREATE_POST Action，并且将之前的 action payload 简化为 postData 和 userId ，因为我们可以通过小程序云数据库查询 userId 得到创建文章的用户信息，所以不需要再携带用户的数据。接着，因为我们不再需要用户的 avatar 和 nickName 数据，所以我们删掉了对应的 useSelector 语句。接着，因为请求是异步的，所以需要等待请求完成之后再设置对应的发表文章的状态以及发表文章弹出层状态，所以我们删掉了对应的 dispatch SET_POST_FORM_IS_OPENED Action 逻辑以及 Taro.atMessage 逻辑。最后我们删掉不需要的常量 SET_POSTS 和 SET_POST_FORM_IS_OPENED ，然后导入异步创建文章的常量 CREATE_POST 。增加 Action 常量我们在上一步中使用到了 CREATE_POST 常量，打开 src/constants/post.js ，在其中增加 CREATE_POST 常量：export const CREATE_POST = 'CREATE_POST'\r\n复制代码到这里，我们的 “六步流程” 讲解法就走完了第一步，即从组件中发起对应的异步请求，这里我们是发出的 action.type 为 CREATE_POST 的异步请求。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 CREATE_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。在 src/sagas/ 文件夹下面创建 post.js 文件，并在其中编写如下创建文章的逻辑：import Taro from '@tarojs/taro'\r\nimport { call, put, take, fork } from 'redux-saga/effects'\r\n\r\nimport { postApi } from '../api'\r\nimport {\r\n  CREATE_POST,\r\n  POST_SUCCESS,\r\n  POST_ERROR,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n} from '../constants'\r\n\r\nfunction* createPost(postData, userId) {\r\n  try {\r\n    const post = yield call(postApi.createPost, postData, userId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起发帖成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 关闭发帖框弹出层\r\n    yield put({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened: false } })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts: [post],\r\n      },\r\n    })\r\n\r\n    // 提示发帖成功\r\n    Taro.atMessage({\r\n      message: '发表文章成功',\r\n      type: 'success',\r\n    })\r\n  } catch (err) {\r\n    console.log('createPost ERR: ', err)\r\n\r\n    // 发帖失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n\r\n    // 提示发帖失败\r\n    Taro.atMessage({\r\n      message: '发表文章失败',\r\n      type: 'error',\r\n    })\r\n  }\r\n}\r\n\r\nfunction* watchCreatePost() {\r\n  while (true) {\r\n    const { payload } = yield take(CREATE_POST)\r\n\r\n    console.log('payload', payload)\r\n\r\n    yield fork(createPost, payload.postData, payload.userId)\r\n  }\r\n}\r\n\r\nexport { watchCreatePost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchCreatePost ，它用来监听 action.type 为 CREATE_POST 的 action，并且当监听到 CREATE_POST action 之后，从这个 action 中获取必要的 postData 和 userId 数据，然后激活 handlerSaga ： createPost 去处理对应的创建帖子的逻辑。这里的 watcherSaga ： watchCreatePost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 CREATE_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 CREATE_POST action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： createPost ，并将 payload.postData 和 payload.userId 作为参数传给 createPost 。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： createPost ，它用来处理创建逻辑。createPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理创建帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi.createPost ，并把 postData 和 userId 作为参数传给这个 API。如果创建帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put类似之前在 view 中的 dispatch 操作，，来 dispatch 了三个 action： POST_SUCCESS ， SET_POST_FORM_IS_OPENED ， SET_POSTS ，代表更新创建帖子成功的状态，关闭发帖框，设置最新创建的帖子信息到 Redux Store 中。最后我们使用了 Taro UI 提供给我们的消息框，来显示一个 success 消息。如果发帖失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新创建帖子失败的信息到 Redux Store，接着使用了 Taro UI 提供给我们的消息框，来显示一个 error 消息。一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：POST_SUCCESS\r\nPOST_ERROR\r\nSET_POSTS\r\nCREATE_POST\r\nSET_POST_FORM_IS_OPENED\r\n这里的 POST_SUCCESS 和 POST_ERROR 我们还没有创建，我们将马上在 “下一剑” 中创建它。以及一些 redux-saga/effects 相关的 helper 函数，我们已经在之前的内容中详细讲过了，这里就不再赘述了。加入 saga 中心调度文件我们像之前将 watchLogin 等加入到 sagas 中心调度文件一样，将我们创建好的 watchCreatePost 也加入进去：// ...之前的逻辑\r\nimport { watchCreatePost } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchCreatePost)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const POST_SUCCESS = 'POST_SUCCESS'\r\nexport const POST_ERROR = 'POST_ERROR'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi ，它里面封装了用于向后端（这里我们是小程序云）发起和帖子有关请求的逻辑，让我们马上来实现它吧。在 src/api/ 文件夹下添加 post.js 文件，并在文件中编写内容如下：import Taro from '@tarojs/taro'\r\n\r\nasync function createPost(postData, userId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  console.log('postData', postData, userId)\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'createPost',\r\n        data: {\r\n          postData,\r\n          userId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('createPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  createPost,\r\n}\r\nexport default postApi;\r\n复制代码在上面的代码中，我们定义了 createPost 函数，它是一个 async 函数，用来处理异步逻辑，在 createPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行创建帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 createPost 云函数，并将 postData 和 userId 作为参数传给云函数，用于在云函数中使用用户 Id 和帖子数据来创建一个属于此用户的帖子并保存到数据库，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post 数据。如果调用失败，则打印错误。最后我们定义了一个 postApi 对象，用于存放所有和用户逻辑有个的函数，并添加 createPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi.createPost 的方式来调用 createPost API 处理创建帖子的逻辑了。在 API 默认文件统一导出在 src/api/index.js 文件中导入上面创建的 postApi 并进行统一导出如下：import postApi from './post'\r\nexport { postApi }\r\n复制代码第五剑：创建对应的微信小程序云函数创建 createPost 云函数按照和之前创建 login 云函数类似，我们创建 createPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/createPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"createPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/createPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/createPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 createPost 云函数打开 functions/createPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postData, userId } = event\r\n\r\n  console.log('event', event)\r\n\r\n  try {\r\n    const user = await db\r\n      .collection('user')\r\n      .doc(userId)\r\n      .get()\r\n    const { _id } = await db.collection('post').add({\r\n      data: {\r\n        ...postData,\r\n        user: user.data,\r\n        createdAt: db.serverDate(),\r\n        updatedAt: db.serverDate(),\r\n      },\r\n    })\r\n\r\n    const newPost = await db\r\n      .collection('post')\r\n      .doc(_id)\r\n      .get()\r\n\r\n    return {\r\n      post: { ...newPost.data },\r\n    }\r\n  } catch (err) {\r\n    console.error(`createUser ERR: ${err}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下七处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，我们首先从 event 对象中取到了在小程序的调用 Taro.cloud.callFunction 传过来的 postData 和 userId 数据。然后，跟着取数据的是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('user').doc(userId).get() ，表示查询 id 为 userId 的 user 表数据，它查出来应该是个唯一值，如果不存在满足 where 条件的，那么是一个 null值，如果存在满足 条件的，那么返回一个 user 对象。接着，我们使用的 db.collection('post').add() 添加一个 post 数据，然后在 add 方法中传入 data 字段，这里我们不仅传入了 postData ，还将 user 也一同传入了，原因我们将在之后来讲解。除此之外，这里我们额外使用了 db.serverDate() 用于记录创建此帖子的时间和更新此帖子的时间，方便之后做条件查询。接着，因为向数据库添加一个记录之后只会返回此记录的 _id ，所以我们需要一个额外的操作 db.collection('post').doc() 来获取此条记录，这个 doc 用于获取指定的记录引用，返回的是这条数据，而不是一个数组。最后我们返回新创建的 post 。提示我们在上面创建 post 的时候，将 user 对象也添加到了 post 数据中，这里是因为小程序云数据库是 JSON 数据库,所以没有关系数据库的外键概念,导致建关系困难,所以为了之后查询 post 的时候方便展示 user 数据，我们才这样保存的. 当然更加科学的做法是在 post 里面保存 userId ，这样能减少数据冗余，但是因为做教学用，所以这些我们偷了一点懒。所以我们这里强烈建议,在正规的环境下，关系型数据库应该建外键，JSON 数据库也至少应该保存 userId 。:第六剑： 定义对应的 reducers 文件我们在前面处理创建帖子时，在组件内部 dispatch 了 CREATE_POST action，在处理异步 action 的 saga 函数中，使用 put 发起了一系列更新 store 中帖子状态的 action，现在我们马上来实现响应这些 action 的 reducers ，打开 src/reducers/post.js ，对其中的代码做出对应的修改如下：import {\r\n  SET_POST,\r\n  SET_POSTS,\r\n  SET_POST_FORM_IS_OPENED,\r\n  POST_ERROR,\r\n  CREATE_POST,\r\n  POST_NORMAL,\r\n  POST_SUCCESS,\r\n} from '../constants/'\r\n\r\nimport avatar from '../images/avatar.png'\r\n\r\nconst INITIAL_STATE = {\r\n  posts: [],\r\n  post: {},\r\n  isOpened: false,\r\n  isPost: false,\r\n  postStatus: POST_NORMAL,\r\n}\r\n\r\nexport default function post(state = INITIAL_STATE, action) {\r\n  switch (action.type) {\r\n    case SET_POST: {\r\n      const { post } = action.payload\r\n      return { ...state, post }\r\n    }\r\n\r\n    case SET_POSTS: {\r\n      const { posts } = action.payload\r\n      return { ...state, posts: state.posts.concat(...posts) }\r\n    }\r\n\r\n    case SET_POST_FORM_IS_OPENED: {...      return { ...state, isOpened }\r\n    }\r\n\r\n    case CREATE_POST: {\r\n      return { ...state, postStatus: CREATE_POST, isPost: true }\r\n    }\r\n\r\n    case POST_SUCCESS: {\r\n      return { ...state, postStatus: POST_SUCCESS, isPost: false }\r\n    }\r\n\r\n    case POST_ERROR: {\r\n      return { ...state, postStatus: POST_ERROR, isPost: false }\r\n    }\r\n\r\n    default:\r\n      return state\r\n  }\r\n复制代码看一看到上面的代码主要有三处改动：首先我们导入了必要的 action 常量接着我们给 INITIAL_STATE 增加了几个字段：posts\r\npost\r\nisPost ：用于标志帖子逻辑过程中是否在执行创帖逻辑， true 表示正在执行创帖中， false 表示登录逻辑执行完毕postStatus ：用于标志创帖过程中的状态：开始创帖（ CREATE_POST ）、创帖成功（ POST_SUCCESS ）、登录失败（ POST_ERROR ）最后就是 switch 语句中响应 action，更新相应的状态。“六脉神剑” 搞定 getPosts 异步逻辑在上一 “大” 节中，我们使用了图雀社区不传之术：“六脉神剑” 搞定了 createPost 的异步逻辑，现在我们马上趁热打铁来巩固我们的武功，搞定 getPosts 异步逻辑，它对应着我们小程序底部两个 tab 栏的第一个，也就是我们打开小程序的首屏渲染逻辑，也就是一个帖子列表。第一剑： index 组件中发起异步请求打开 src/pages/index/index.jsx 文件，对其中的内容作出对应的修改如下：import { PostCard, PostForm } from '../../components'\r\nimport './index.scss'\r\nimport {\r\n  SET_POST_FORM_IS_OPENED,\r\n  SET_LOGIN_INFO,\r\n  GET_POSTS,\r\n} from '../../constants'\r\n\r\nexport default function Index() {\r\n  const posts = useSelector(state => state.post.posts) || []...  const dispatch = useDispatch()\r\n\r\n  useEffect(() => {\r\n    const WeappEnv = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n\r\n    if (WeappEnv) {\r\n      Taro.cloud.init()\r\n    }\r\n\r\n    async function getStorage() {\r\n      try {\r\n        const { data } = await Taro.getStorage({ key: 'userInfo' })\r\n\r\n        const { nickName, avatar, _id } = data\r\n\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: SET_LOGIN_INFO,\r\n          payload: { nickName, avatar, userId: _id },\r\n        })\r\n      } catch (err) {\r\n        console.log('getStorage ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!isLogged) {\r\n      getStorage()\r\n    }\r\n\r\n    async function getPosts() {\r\n      try {\r\n        // 更新 Redux Store 数据\r\n        dispatch({\r\n          type: GET_POSTS,\r\n        })\r\n      } catch (err) {\r\n        console.log('getPosts ERR: ', err)\r\n      }\r\n    }\r\n\r\n    if (!posts.length) {\r\n      getPosts()\r\n    }\r\n  }, [])\r\n\r\n  function setIsOpened(isOpened) {\r\n    dispatch({ type: SET_POST_FORM_IS_OPENED, payload: { isOpened } })...  return (\r\n    <View className=\"index\">\r\n      <AtMessage />\r\n      {posts.map(post => (\r\n        <PostCard key={post._id} postId={post._id} post={post} isList />\r\n      ))}\r\n      <AtFloatLayout\r\n        isOpened={isOpened}\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们对当前的开发环境做了判断，如果是微信小程序环境，我们就使用 Taro.cloud.init() 进行小程序环境的初始化。接着，我们在 useEffects Hooks 里面定义了 getPosts 函数，它是一个异步函数，用于 dispatch GET_POSTS 的异步请求，并且我们进行了判断，当此时 Redux Store 内部没有文章时，才进行数据的获取。接着，我们改进了 getStorage 获取缓存的函数，将其移动到 useEffects Hooks 里面，并额外增加了 _id 属性，它被赋值给 userId 一起设置 Redux Store 中关于用户的属性，这样做的目的主要是为了之后发帖标志用户，或者获取用户的个人信息用。并且，加了一层 if 判断，只有当没有登录时，即 isLogged 为 false 的时候，才进行获取缓存操作。最后我们导入了必要的 GET_POSTS 常量，并且将 return 语句里的 PostCard 接收的 key 和 postId 属性变成了真实的帖子 _id 。这样我们在帖子详情时可以直接拿 postId 向小程序云发起异步请求。注意在上一篇教程中，有同学提到没有使用 Taro.cloud.init() 初始化的问题，是因为分成了两篇文章，在这篇文章才初始化。要使用小程序云，初始化环境是必要的。第二剑：声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POSTS 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：import {\r\n  GET_POSTS,\r\n} from '../constants'\r\n\r\nfunction* getPosts() {\r\n  try {\r\n    const posts = yield call(postApi.getPosts)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POSTS,\r\n      payload: {\r\n        posts,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPosts ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPosts() {\r\n  while (true) {\r\n    yield take(GET_POSTS)\r\n\r\n    yield fork(getPosts)\r\n  }\r\n}\r\n\r\nexport { watchGetPosts }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPosts ，它用来监听 action.type 为 GET_POSTS的 action，并且当监听到 GET_POSTS action 之后，然后激活 handlerSaga ： getPosts 去处理对应的获取帖子列表的逻辑。这里的 watcherSaga ： watchGetPosts 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POSTS action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POSTS action，获取 action 中携带的数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPosts ，因为这里获取帖子列表不需要传数据，所以这里没有额外的数据传递逻辑。创建 handlerSaga我们创建了创建帖子的 handlerSaga ： getPosts ，它用来处理创建逻辑。getPosts 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取帖子列表请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPosts 。如果获取帖子列表成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取帖子列表成功的状态，设置最新获取的帖子列表到 Redux Store 中。如果获取帖子列表失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取帖子列表失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi. getPosts ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：GET_POSTS ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它。加入 saga 中心调度文件我们像之前将 watchCreatePost 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPosts 也加入进去：// ...之前的逻辑\r\nimport { watchGetPosts } from './post'\r\nexport default function* rootSaga() {\r\n  yield all([\r\n   // ... 之前的逻辑\r\n    fork(watchGetPosts)\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件如下：export const GET_POSTS = 'GET_POSTS'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPosts ，它里面封装了用于向后端（这里我们是小程序云）发起和获取帖子列表有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其余逻辑一样\r\nasync function getPosts() {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPosts',\r\n      })\r\n\r\n      return result.posts\r\n    }\r\n  } catch (err) {\r\n    console.error('getPosts ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  // ... 之前的 API\r\n  getPosts,\r\n}\r\n\r\n// ... 其余逻辑一样\r\n复制代码在上面的代码中，我们定义了 getPosts 函数，它是一个 async 函数，用来处理异步逻辑，在 getPosts 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取帖子列表的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPosts 云函数，我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.posts数据，即从小程序云返回的帖子列表。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPosts API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPosts 的方式来调用 getPosts API 处理获取帖子列表的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPosts 云函数按照和之前创建 createPost 云函数类似，我们创建 getPosts 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPosts/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPosts\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPosts/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPosts 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPosts 云函数打开 functions/getPosts/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try {\r\n    const { data } = await db.collection('post').get()\r\n\r\n    return {\r\n      posts: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPosts ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们使用 db 的查询操作： db.collection('post').get() ，表示查询所有的 post 数据。最后我们返回查询到的 posts 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POSTS 的 Action 我们在上一 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。“六脉神剑” 搞定 getPost 异步逻辑在上面两 “大” 节中，我们连续用了两次 “六脉神剑”，相信跟到这里的同学应该对我们接下来要做的事情已经轻车熟路了吧:grin:。接下来，我们将收尾 Post 逻辑的最后一公里，即帖子详情的异步逻辑 “getPost” 接入，话不多说就是干！第一剑： post 组件中发起异步请求打开 src/pages/post/post.jsx 文件，对其中的内容作出对应的修改如下：import Taro, { useRouter, useEffect } from '@tarojs/taro'\r\nimport { View } from '@tarojs/components'\r\nimport { useDispatch, useSelector } from '@tarojs/redux'\r\n\r\nimport { PostCard } from '../../components'\r\nimport './post.scss'\r\nimport { GET_POST, SET_POST } from '../../constants'\r\n\r\nexport default function Post() {\r\n  const router = useRouter()\r\n  const { postId } = router.params\r\n\r\n  const dispatch = useDispatch()\r\n  const post = useSelector(state => state.post.post)\r\n\r\n  useEffect(() => {\r\n    dispatch({\r\n      type: GET_POST,\r\n      payload: {\r\n        postId,\r\n      },\r\n    })\r\n\r\n    return () => {\r\n      dispatch({ type: SET_POST, payload: { post: {} } })\r\n    }\r\n  }, [])\r\n\r\n  return (\r\n    <View className=\"post\">\r\n复制代码可以看到，上面的内容做了如下四处修改：首先我们使用 useDispatch Hooks 获取到了 dispatch 函数。接着，在 useEffects Hooks 里面定义了 dispatch 了 action.type 为 GET_POST 的 action，它是一个异步 Action，并且我们在 Hooks 最后返回了一个函数，其中的内容为将 post 设置为空对象，这里用到的 SET_POST 常量我们将在后面定义它。这个返回函数主要用于 post 组件卸载之后，Redux Store 数据的重置，避免下次打开帖子详情还会渲染之前获取到的帖子数据。接着，我们使用 useSelector Hooks 来获取异步请求到的 post 数据，并用于 return 语句中的数据渲染。最后我们删除了不必要的获取 posts 数据的 useSelector Hooks，以及删掉了不必要的调试 console.log 语句。第二剑： 声明和补充对应需要的异步 sagas 文件在 “第一剑” 中，我们从组件中 dispatch 了 action.type 为 GET_POST 的异步 Action，接下来我们要做的就是在对应的 sagas 文件中补齐响应这个异步 action 的 sagas。打开 src/sagas/post.js 文件，在其中定义 getPosts sagas 逻辑如下：// ... 和之前的逻辑一样\r\nimport {\r\n  // ... 和之前的逻辑一样\r\n  SET_POST,\r\n} from '../constants';\r\n\r\n  // ... 和之前的逻辑一样\r\n\r\nfunction* getPost(postId) {\r\n  try {\r\n    const post = yield call(postApi.getPost, postId)\r\n\r\n    // 其实以下三步可以合成一步，但是这里为了讲解清晰，将它们拆分成独立的单元\r\n\r\n    // 发起获取帖子成功的 action\r\n    yield put({ type: POST_SUCCESS })\r\n\r\n    // 更新 Redux store 数据\r\n    yield put({\r\n      type: SET_POST,\r\n      payload: {\r\n        post,\r\n      },\r\n    })\r\n  } catch (err) {\r\n    console.log('getPost ERR: ', err)\r\n\r\n    // 获取帖子失败，发起失败的 action\r\n    yield put({ type: POST_ERROR })\r\n  }\r\n}\r\nfunction* watchGetPost() {\r\n  while (true) {\r\n    const { payload } = yield take(GET_POST)\r\n\r\n    yield fork(getPost, payload.postId)\r\n  }\r\n}\r\n\r\nexport { watchGetPost }\r\n复制代码可以看到，上面的改动主要是创建 watcherSaga 和 handlerSaga 。创建 watcherSaga我们创建了登录的 watcherSaga ： watchGetPost ，它用来监听 action.type 为 GET_POST的 action，并且当监听到 GET_POST action 之后，然后激活 handlerSaga ： getPost 去处理对应的获取单个帖子的逻辑。这里的 watcherSaga ： watchGetPost 是一个生成器函数，它内部是一个 while 无限循环，表示在内部持续监听 GET_POST action。在循环内部，我们使用了 redux-saga 提供的 effects helper 函数： take ，它用于监听 GET_POST action，获取 action 中携带的数据，这里我们拿到了传过来的 payload 数据。接着我们使用了另外一个 effects helper 函数： fork ，它表示非阻塞的执行 handlerSaga： getPost ，并传入了获取到 payload.postId 参数。创建 handlerSaga我们创建了获取单个帖子的 handlerSaga ： getPost ，它用来处理获取帖子逻辑。getPost 也是一个生成器函数，在它内部是一个 try/catch 语句，用于处理获取单个帖子请求可能存在的错误情况。在 try 语句中，首先是使用了 redux-saga 提供给我们的 effects helper 函数： call 来调用登录的 API： postApi. getPost 。如果获取单个帖子成功，我们使用 redux-saga 提供的 effects helpers 函数： put ， put 类似之前在 view 中的 dispatch 操作，，来 dispatch 了两个 action： POST_SUCCESS ， SET_POSTS ，代表更新获取单个帖子成功的状态，设置最新获取的帖子到 Redux Store 中。如果获取单个帖子失败，我们则使用 put 发起一个 POST_ERROR 的 action 来更新获取单个帖子失败的信息到 Redux Store一些额外的工作为了创建 watcherSaga 和 handlerSaga ，我们还导入了 postApi.getPost ，我们将在后面来创建这个 API。除此之外我们还导入了需要使用的 action 常量：SET_POST ：响应获取帖子列表的 ACTION 常量，我们将在 “第三剑” 中创建它加入 saga 中心调度文件我们像之前将 watchGetPosts 等加入到 sagas 中心调度文件一样，将我们创建好的 watchGetPost 也加入进去：打开 src/sagas/index.js 文件，对其中的内容作出如下的修改：import { fork, all } from 'redux-saga/effects'\r\n\r\nimport { watchLogin } from './user'\r\nimport { watchCreatePost, watchGetPosts, watchGetPost } from './post'\r\n\r\nexport default function* rootSaga() {\r\n  yield all([\r\n    fork(watchLogin),\r\n    fork(watchCreatePost),\r\n    fork(watchGetPosts),\r\n    fork(watchGetPost),\r\n  ])\r\n}\r\n复制代码第三剑：定义 sagas 需要的常量文件打开 src/constants/post.js 文件，定义我们之前创建的常量文件 GET_POST ：export const SET_POST = 'SET_POST'\r\n复制代码第四剑：定义 sagas 涉及到的前端 API 文件在之前的 post saga 文件里面，我们使用到了 postApi.getPost ，它里面封装了用于向后端（这里我们是小程序云）发起和获取单个帖子有关请求的逻辑，让我们马上来实现它吧。打开 src/api/post.js 文件，并在其中编写内容如下：// ... 其他内容和之前一致\r\nasync function getPost(postId) {\r\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\r\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\r\n\r\n  // 针对微信小程序使用小程序云函数，其他使用小程序 RESTful API\r\n  try {\r\n    if (isWeapp) {\r\n      const { result } = await Taro.cloud.callFunction({\r\n        name: 'getPost',\r\n        data: {\r\n          postId,\r\n        },\r\n      })\r\n\r\n      return result.post\r\n    }\r\n  } catch (err) {\r\n    console.error('getPost ERR: ', err)\r\n  }\r\n}\r\n\r\nconst postApi = {\r\n  getPost,\r\n}\r\nexport default postApi\r\n复制代码可以看到上面的代码有如下六处改动：在上面的代码中，我们定义了 getPost 函数，它是一个 async 函数，用来处理异步逻辑，在 getPost 函数中，我们对当前的环境进行了判断，且只在微信小程序，即 isWeapp 的条件下执行获取单个帖子的操作，对于支付宝小程序和 H5，我们则放在下一节使用 LeanCloud 的 Serverless 来解决。创建帖子逻辑是一个 try/catch 语句，用于捕捉可能存在的请求错误，在 try 代码块中，我们使用了 Taro 为我们提供的微信小程序云的云函数 API Taro.cloud.callFunction 来便捷的向小程序云发起云函数调用请求。这里我们调用了一个 getPost 云函数，并给它传递了对应要获取的帖子的 postId 我们将在下一节中实现这个云函数。如果调用成功，我们可以接收返回值，用于从后端返回数据，这里我们返回了 result.post数据，即从小程序云返回的单个帖子。如果调用失败，则打印错误。最后我们在已经定义好的 postApi 对象里，添加 getPost API 属性然后将其导出，这样在 post saga 函数里面就可以导入 postApi 然后通过 postApi. getPost 的方式来调用 getPostAPI 处理获取单个帖子的逻辑了。第五剑：创建对应的微信小程序云函数创建 getPost 云函数按照和之前创建 getPosts 云函数类似，我们创建 getPost 云函数。创建成功之后，我们可以得到两个文件，一个是 functions/getPost/package.json 文件，它和之前的类似。{\r\n  \"name\": \"getPost\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\"\r\n  }\r\n}\r\n复制代码第二个文件就是我们需要编写创建帖子逻辑的 functions/getPost/index.js 文件，微信小程序开发者工具会默认为我们生成一段样板代码。我们在 function/getPost 文件夹下同样运行 npm install 安装对应的云函数依赖，这样我们才能运行它。编写 getPost 云函数打开 functions/getPost/index.js 文件，对其中的内容作出对应的修改如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV,\r\n})\r\n\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const { postId } = event\r\n\r\n  try {\r\n    const { data } = await db\r\n      .collection('post')\r\n      .doc(postId)\r\n      .get()\r\n\r\n    return {\r\n      post: data,\r\n    }\r\n  } catch (e) {\r\n    console.error(`getPost ERR: ${e}`)\r\n  }\r\n}\r\n复制代码可以看到上面的代码改动主要有以下处：首先我们给 cloud.init() 传入了环境参数，我们使用了内置的 cloud.DYNAMIC_CURRENT_ENV，表示自动设置为当前的云环境，即在右键点击小程序开发者工具里 functions 文件夹时选择的环境。接着，我们通过 cloud.database() 生成了数据实例 db ，用于之后在函数体中便捷的操作云数据库。接着就是 main 函数体，里面是一个 try/catch 语句块，用于捕获错误，在 try 语句块中，我们首先从 event 对象里面获取到了 postId ，接着我们使用 db 的查询操作： db.collection('post').doc(postId).get() ，表示查询所有的对应 _id 为 postId 的单个帖子数据最后我们返回查询到的 post 数据。第六剑： 定义对应的 reducers 文件因为这里 SET_POST 的 Action 我们在上上 “大” 节中创建帖子时已经定义了，所有在 “这一剑” 中我们无需添加额外的代码，复用之前的逻辑就好。小结在这篇教程中，我们连续使用了三次 “六脉神剑” 讲完了我们的 Post 逻辑的异步流程，让我们再来复习一下我们开头提到的 “六脉神剑”：sagas\r\nsagas\r\nsagas\r\nreducers\r\n这是一套讲解模式，也是一套写代码的最佳实践方式之一，希望你能受用。"}
{"title": "小白如何自己亲手制作一个防疫地图？ ", "author": "Rolan", "time": "2020-2-20 00:22", "content": "最近出了好几个小程序可以查看你周边地区当前疫情确诊人数的情况，就比如下面这种的：这张图对于身为小白的我们可不可以自己做一个呢？答案当然是肯定的，这里面涉及到的技术点就是地图上的那些点是如何标记出来的。这里的地图我们使用腾讯地图来实现，首先进入到腾讯位置服务的首页（ https://lbs.qq.com/index.html ），进行登录操作，用 QQ 也好微信也好，反正先登录上去。然后在控制台中新建一个 key ，这个 key 是专属于你一个人使用的，所以千万不要外传哦~~~这里我们新建一个专门用于本次疫情地图的 key ，名称输入完成后，再输入验证码点击提交即可，这时会弹出来了一个让你去设置 key 的提示。这里我们就获得了自己的 key （小编已删除此 key ，请不要直接使用小编所创建的 key），点击设置进入设置页面：可以看到，这里可以设置这个 key 所应用的茶品，默认是 JavaScriptAPI ，我们还可以在微信小程序、APP、或者 WebServiceAPI（服务器调用） 中使用。这里其实不需要多余的设置，直接点击保存即可。我们本次示例所使用到的功能都是最基础的功能。key 设置完成后我们看一下腾讯地图的 API ，这里主要是看 JavaScript API ，链接：https://lbs.qq.com/javascript_v2/index.html 。我们本次要用到的功能是覆盖物，其他的感兴趣的同学可以看一看，不感兴趣的同学可以直接略过，点开覆盖物查看今天的正题。直接看代码好没意思，点击查看示例，可以一边看示例，一边看代码，顺手改改，看看能不能正常运行。点击查看示例以后，就变成下面这个样子了：这里可以看到他的中心点是在北京，实际上是由这段代码来指定的：    var center = new qq.maps.LatLng(39.916527,116.397128);\r\n    var map = new qq.maps.Map(document.getElementById('container'),{\r\n        center: center,\r\n        zoom: 13\r\n    });如果小编这里要改成上海的话只需要修改这里的坐标值即可，那么上海的坐标值我能去哪里查找呢？别急，这里就要说到今天会用到的另一个功能点，坐标拾取器，腾讯也提供了这样的服务，链接为：https://lbs.qq.com/tool/getpoint/index.html ，他是长这个样子的：比如小编这里将地图的中心点改成人民广场地铁站，那么直接将上面的坐标 Copy 出来，放在刚才的代码中再执行一下，就可以看到当前的地图中心点编程了人民广场。那么，接下来的事情就好办了，我们只需要知道附近的疫情的数据，将这些有疫情的区域全都标记在地图上就好了，小编这里就不查真实的疫情情况了，随便在地图上取几个点做演示。结果就变成了这样：接下来问题来了，我们看到的地图上的标记好像图形和这个不一样嘛，这个长得也有点忒丑了点，当然，腾讯地图给我们提供的 API 同样支持自定义的 icon ，示例如下：emmmmmmmmmmm，手头没有找到好看一点的 icon ，随便找了一张代替，大家理解到位就好。只要我们替换上合适的 icon ，就可以做出和文章最前面那个小程序一样漂亮的疫情地图了。最后的没有替换 icon 的代码小编还是顺手贴一下吧：<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>\r\n<title>疫情地图</title>\r\n<script charset=\"utf-8\" src=\"https://map.qq.com/api/js?v=2.exp&key=你的key\"></script>\r\n<style type=\"text/css\">\r\n*{\r\n    margin:0px;\r\n    padding:0px;\r\n}\r\nbody, button, input, select, textarea {\r\n    font: 12px/16px Verdana, Helvetica, Arial, sans-serif;\r\n}\r\n#info{\r\n    width:603px;\r\n    padding-top:3px;\r\n    overflow:hidden;\r\n}\r\n.btn{\r\n    width:112px;\r\n}\r\n#container{\r\n    min-width:600px;\r\n    min-height:767px;\r\n}\r\n</style>\r\n<script>\r\nvar init = function() {\r\n    var center = new qq.maps.LatLng(31.232708,121.475537);\r\n    var map = new qq.maps.Map(document.getElementById('container'),{\r\n        center: center,\r\n        zoom: 13\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.232105,121.481667),\r\n        map: map\r\n    });\r\n    \r\n  \r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.235114,121.471281),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.227261,121.480465),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.226821,121.471796),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.216545,121.467419),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.216839,121.480808),\r\n        map: map\r\n    });\r\n    //创建marker\r\n    var marker = new qq.maps.Marker({\r\n        position: new qq.maps.LatLng(31.218454,121.492825),\r\n        map: map\r\n    });\r\n    \r\n}\r\n</script>\r\n</head>\r\n<body onload=\"init()\">\r\n<div id=\"container\"></div>\r\n</body>\r\n</html>\r\n这里只需要替换一个可用的 key 即可使用。到这里，你可以把所有已经有确诊患者小区的经纬度获取到，然后全部标注到地图上，每天对标注进行实时更新，这样就制作成了一张防疫地图了，有兴趣的同学可以自己去尝试尝试。实际上腾讯地图上还有很多很好玩的同时也很炫酷的功能，如以下图形：大家可以自己去探索。"}
{"title": "小程序时代：如何跨多小程序开发协作？ ", "author": "Rolan", "time": "2020-2-20 00:31", "content": "导语小程序端越来越多，\t跨平台开发框架逐渐成为开发小程序的主流 ，\t目前跨平台开发有较多的开源解决方案 ，本文介绍一种简单而有效的方法，解决复杂小程序的跨团队开发协作，希望对你有所帮助。背景目前市面上小程序端越来越多，跨平台开发框架逐渐成为开发小程序的主流。目前跨平台开发有较多的开源解决方案，比如美团点评的mpvue、滴滴的Chameleon、凹凸实验室的Taro等，都做得比较好。这些框架帮我们解决了一处开发，多处运行的难点。但是在复杂的业务场景中，最终落地也存在着许多困难，需要自己解决。以58房产的新房业务小程序为例，实际的业务场景中，既需要有独立承载功能的“58同城新房楼盘精选”小程序，也有依托于其他流量平台的入口，比如在“58同城”、“安居客买房”等都有相应的新房业务，同时还有交叉的业务场景，比如在同经纪人业务结合的“安居客经纪人网店”中展示新房楼盘。这其中既有微信小程序，也有百度小程序。这些业务有较多的共同点，比如基础功能逻辑是一致的，但是也存在很多差异性，比如商业逻辑，页面皮肤以及一些差异功能点。新房首页对比上图为三个小程序的首页对比，可以看到独立的小程序“58同城新房楼盘精选”集成了账号、城市、消息，在“58同城”和“安居客买房”这些能力则是依赖主体小程序。另外三个小程序之间还有些细微差别，但是楼盘相关的基础功能确是相同的。一处开发多处运行的难题作为业务方，我们希望业务代码也可以一处开发，到处运行。方案设计之时，我们的目标便是业务代码在同一仓库管理，同时方案具备较大的灵活性以适配各种环境。在上述的背景下，实际开发中会遇到如下困难：a) 各个小程序归属的开发团队不一样，使用的开发方案也不一样，有原生开发、wepy、Taro、mpvue等，意味着在源码层面是难以进行协作开发的；b) 业务方与平台方之间是跨团队协作，需要尽量减少耦合，提高协作效率，同时避免相互影响；c) 需要具备在各个小程序环境中的差异化开发方案；d) 所有业务代码同一地方管理，意味着会有不必要的代码，需要有机制保障最终的打包结果大小是最优的；e) 在不同平台小程序中，会依赖他们各自提供的基础能力，比如账户体系，消息等，这部分在各平台小程序中也存在着一定差异性；f) 在不同场景下需要具备不同的接入方案，支持微信插件方式接入平台小程序，也要支持业务分包方式接入平台小程序。整体架构设计本方案基于Taro 1.3版本实现，其他小程序框架也可使用相同的方法做改造。在现有Taro基础上，无法支持到一份源码打包成多个同类型的小程序，因此在现有配置层进行扩展处理，并添加适配层，对于各个小程序不同点进行处理，最终实现直接打包到多个不同的小程序中，整体的架构主要分为四层： a) 配置层，用于解决在不同场景下的差异化，包括环境变量、主题样式、页面配置等；b) 源码层，为具体的业务代码，常见方案，不做具体介绍；c) 适配层，用于对接不同方案下小程序提供的接口，并牟平不同小程序提供的接口差异，为源码层提供统一的接口；d) 打包层，与配置层相结合，用于打包最终交付结果；以新房为例的架构图：1.  配置层处理1） 打包脚本配置若要支持多小程序开发，需在package.json中增加scripts，用于区分环境。这里我们用的是cross-env这个包来设置，比如在打包58同城小程序时，加入环境变量WEAPPSOURCE=wbweapp。{    \"build:weapp\": \"taro build --type weapp\",    \"build:wbweapp\": \"cross-env WEAPPSOURCE=wbweapp taro build --type weapp\",    \"dev:wbweapp\": \"cross-env WEAPPSOURCE=wbweapp npm run build:weapp -- --watch\",}然后在`config/index.js`配置defineConstants，用来配置一些编译时的全局变量供代码中使用，这里的配置会用于做打包的差异化处理。大部分的差异化配置，我们都放到了编译时来进行配置，有助于降低代码打包后的大小。其原理是通过webpack的define-plugin和uglifyjs-webpack-plugin两个插件配合来删除掉不可达代码，保证不使用的代码不会被打包。config.defineConstants = {    WEAPPSOURCE: JSON.stringify(process.env.WEAPPSOURCE),    WBWEAPP: '\"wbweapp\"',    AJKWEAPP: '\"ajkweapp\"',}2） 差异性样式处理在现有业务中，需要同时支持58同城和安居客两个品牌。二者之间页面结构是一致的，但各自有些主题色，我们将这部分差异抽取出来，变成Sass变量，然后整合至一个scss文件中，通过编译时引入不同的scss文件，来达到切换主题的作用。这里主要是配置`config/index.js`中的`config.plugins.sass.resource` 。const sassConfig = {    wbweapp: '../wbweapp.scss',    ajkweapp: '../ajkweapp.scss'}config.plugins.sass.resource = path.resolve(__dirname, sassConfig[process.env.WEAPPSOURCE])3）差异化页面处理源码层中会包含所有场景下的全量页面，但每个场景所需的页面只是其中的一部分，需要做差异化处理。处理方法同上，略有差异点，通过编译打包时pages的配置不同，在`app.tsx`中的pages是决定引入哪些页面，我们通过传入环境变量找到对应的配置页面，实现按需配置打包。`config/index.js`中配置：const pagesConfig = {    wbweapp: ['pages/a'],    ajkweapp: ['pages/b']}config.defineConstants = {    PAGES: JSON.stringify(pagesConfig[process.env.WEAPPSOURCE])}`app.tsx`中配置：class App extends Component {    config: Config = {        pages: PAGES,    }}2.  适配层处理1） 差异化功能处理功能的差异化处理，使用配置层定义的全局变量来做，伪代码如下：import TabBar from '../components/tabbar';export default class _C extends Component {    render() {        return {(WEAPPSOURCE == WBWEAPP) && <TabBar/>}    }}这样写的话，当WEAPPSOURCE !== WBWEAPP时，TabBar组件不会被打包到最终代码中，wxml文件中TabBar的代码块也不会有。上面的import是不需要做特殊处理，打包时会分析依赖关系，没有被最终使用的文件不会被编译。2） 接口统一封装处理在各个平台方小程序中，通用功能都应该是统一管理的。比如用户信息，用户在58同城小程序内进行登录，各业务都能拿到统一的用户信息，而不是进入新房页面后再做一次新房的登录。这些功能，由平台方提供接口，供业务方调用。但各个平台存在差异性，这些差异性就由适配层做统一的封装，对业务开发提供一致的接口。比如获取城市信息：export const getCityInfo = () => {    if (WEAPP_SOURCE == WBWEAPP) {        city_info = WBIndex.WB.getCityInfo()    } else if (WEAPP_SOURCE == AJKWEAPP) {        city_info = AJKIndex.Common.getCityInfo();     } }原理解析通过以上介绍，已经解决了我们对差异化开发的要求，同时适配层将平台接口差异牟平，业务开发也不需要关心所处环境。大家可能比较好奇，所有的小程序代码都放在一起管理，最终打包出来的代码大小是不是最优的？主要是以下两点：1）  在开发中注意利用条件编译来删除不必要的代码；2）  在打包时做依赖分析及打包优化，业务层尽可能做更少的事情；依赖分析优化工作主要是由@tarojs/cli包来完成的，简化后的流程图如下：首先是解析入口文件`app.tsx`，通过两次语法转换，一次语法遍历，得到了依赖的样式文件、依赖的js文件、app的配置等，以及入口文件app.js。样式文件编译成最终的app.css，依赖的js文件，通过拷贝或生成，放到指定的目录中，app配置生成app.json。两次语法转换是不一样的，第一次是通用的语法转换，比如jsx语法的处理。第二次是差异化的转换，会根据当前转换的类型是入口文件、页面文件或组件文件做一些特殊处理。第二次转换时使用了babel-plugin-danger-remove-unused-import插件，会删除不必要的依赖引入。上文提到的TabBar组件，虽然是被引入了，但在不需要的场景下TabBar组件就不会被打包。这里需要注意引入的文件，不应该存在副作用。解析完入口文件后，会得到app配置的pages列表，页面文件列表循环通过同样的过程，得到页面的样式、js、配置等，以及所依赖的组件列表。组件文件的打包过程跟页面是基本一致的，区别点在于组件会依赖其他组件。理解了整个打包的流程，上面的问题答案就比较清晰了，不在pages配置里的页面是不会最终打包输出的，没有被依赖到的文件也是不会经过打包处理的。与平台小程序集成小程序最终的集成发布有三种方式：独立发布、插件集成、分包集成。多个小程序的不同集成方案1. 插件集成发布如果是通过小程序插件方式集成，平台小程序可以将接口统一挂载到插件的变量中，二者就桥接上了。插件的index.js设置（上文WBIndex即为引入的此文件）：module.exports = {WB: {},}平台小程序接口注入方法：const plugin = requirePlugin(\"xinfang\");plugin.WB = {    getCityInfo: function() {}}2. 分包集成发布如果是分包集成的话，可以考虑将接口直接挂载在App中。平台小程序接口注入方法（上文AJKIndex即为getApp()）：getApp().Common.getCityInfo = function() {}采用分包集成方案的话需要注意，因为双方是在各自仓库下分别开发的，最终需要和到一起进行打包发布。目前我们采用的方案是配置`config.outputRoot`将结果代码打包到平台小程序仓库中，通过git管理，再由平台小程序做发布。3.独立小程序发布方案跟分包集成发布是一致的，不过API由自己提供，也挂载在App中，同时扮演了平台方和业务方。实践经验分享a) 小程序包依赖的json文件的处理，比如插件需要有插件配置文件`plugin/plugin.json`。可通过配置`config.copy.patterns`指定需要拷贝的文件或者目录来实现；b) 小程序是插件和分包处理，在不同场景下的页面跳转路径是不一样的，但其实相对的路径是一致的，在于跳转前缀不同，可将页面跳转统一封装到适配层，根据环境变量适配不同的加上对应的前缀，当需要由插件切换到分包时，跳转部分仅需修改前缀，无需额外处理；问题解决前面提到一处开发多处运行的难题，得到了一一解决，整理如下：a) 源码层面无法进行跨团队协作开发？团队间分仓库开发，最终代码通过微信插件方式，或者分包方式进行集成。b) 业务方与平台方之间的如何解耦？通过统一的API，进行桥接，无其他耦合，API根据集成方式的不同，有不同的挂载方案。c) 如何进行差异化开发？针对样式差异化，配置差异化，功能差异化均给出了方法。d) 如何保证打包结果是最优的？尽可能的利用编译时的条件编译方法，排除不必要代码。e) 平台方接口的差异性如何牟平？增加了适配层，对业务提供一致的输入输出接口。f) 支持不同平台小程序的多种接入方案？支持了插件接入与分包接入。总结与规划本文介绍了在较复杂的小程序业务场景中，跨多小程序跨团队的协作方案，该方案帮助了新房业务在多小程序中的快速落地及迭代。在实现了“58同城”小程序中的新房业务接入后，我们又做了“58同镇”的新房业务对接。只需要“58同镇”小程序提供一致的基础能力接口，即可轻松接入。本文内容主要为业务经验积累，整体方案易于实施，带来的业务开发提效却是显著的，希望能帮助到大家。实际业务落地过程中，还有较多的细节需要处理，无法一一列举，欢迎提问或咨询。文中仅介绍了业务在微信小程序的实践情况，实际上在百度小程序以及H5也已有相应落地实践，具备了一定的通用性，可以放心使用。随着业务覆盖的范围越来越广，适配层会越来越复杂，不利于维护，更有效的方案是把业务实践总结为一套通用的接口标准，各个小程序按统一标准来实现API，业务方可以不关心所处环境的差异性，进一步提高跨团队开发的协作效率。 参考文献1. https://www.npmjs.com/package/cross-env2. https://nervjs.github.io/taro/docs/config.html3. https://webpack.js.org/plugins/define-plugin/4. https://www.npmjs.com/package/uglifyjs-webpack-plugin5. https://github.com/mishoo/UglifyJS2#compress-options 作者简介陈志庆 58同城资深研发工程师叶春喜 58同城高级研发工程师"}
{"title": "小程序实现图片模糊预加载--超详情教程 ", "author": "Rolan", "time": "2020-2-20 00:41", "content": "导语\r\n最近在做的小程序项目设计大量图片的展示，小程序已经提供了图片的懒加载功能，但是由于图片本身比较大加上要展示的图片比较多，如何以一个比较友好的方式展示未加载完成的过程就是一个必须解决的问题了。\r\n思路\r\n由于小程序没有提供 Image 这个 js 对象，所以在小程序中实现预加载不能直接像原生js 一样，直接使用 new Image()创建一个图片对象，只能在视图层创建图片，通过onLoad事件监听图片加载完成。\r\n实现图片模糊加载的思路就是先加载一个目标图片的缩略图，缩略图的加载一般非常快可以忽略不计，缩略图加载完成之后以高斯模糊的形式展示，与此同时加载原图，原图加载完成后替代原缩略图，原图和缩略图需要设置相同的宽高。\r\n思路理清楚之后，开始码代码吧～\r\n\r\n由于项目使用了Taro框架，下面的代码写法是React的写法，原生或者其他框架也可以参考，没有太大的出入，思路都是一样的。\r\n\r\nimgLoader.js(以下为部分代码)\r\n       // 监听原图加载完成\r\n\ttoggleOriginLoaded() {\r\n\t\tthis.setState({\r\n\t\t\tloaded: true\r\n\t\t});\r\n\t}\r\n\t// 监听缩略图加载完成\r\n\ttoggleThumbLoaded() {\r\n\t\tthis.setState({\r\n\t\t\tthumbLoaded: true\r\n\t\t});\r\n\t}\r\n\t\r\n\trender() {\r\n\t\tlet { loaded, thumbLoaded } = this.state;\r\n\t\tlet { imgU, imgW, imgH } = this.props;\r\n\t\t// 根据传入的宽高设置缩略图和原图的宽高\r\n\t\tlet style = {\r\n\t\t\twidth: imgW + 'rpx',\r\n\t\t\theight: imgH + 'rpx'\r\n\t\t}\r\n\t\t\r\n\t\treturn (\r\n\t\t\t<Block>\r\n\t\t\t\t<Image\r\n\t\t\t\t\tclassName='image--not-loaded'\r\n\t\t\t\t\tstyle={Object.assign({ display: loaded ? 'none' : 'auto' }, style)}\r\n\t\t\t\t\tlazyLoad\r\n\t\t\t\t\tmode='aspectFill'\r\n\t\t\t\t\tonLoad={this.toggleThumbLoaded.bind(this)}\r\n\t\t\t\t\tsrc={compressImage(imgU, '10x' + parseInt(imgH * 10 / imgW))}\r\n\t\t\t\t/>\r\n\t\t\t\t{thumbLoaded && (\r\n\t\t\t\t\t<Image\r\n\t\t\t\t\t\tstyle={Object.assign({ display: loaded ? 'auto' : 'none' }, style)}\r\n\t\t\t\t\t\tlazyLoad\r\n\t\t\t\t\t\tclassName='image--is-loaded'\r\n\t\t\t\t\t\tmode='aspectFill'\r\n\t\t\t\t\t\tsrc={imgU}\r\n\t\t\t\t\t\tonLoad={this.toggleOriginLoaded.bind(this)}\r\n\t\t\t\t\t/>\r\n\t\t\t\t)}\r\n\t\t\t</Block>\r\n\t\t);\r\n\t}\r\n复制代码以上为主要视图层和逻辑层代码，其中compressImage函数是用来处理图片剪裁也就是缩略图的生成的，(ps：我们是用nginx实现的动态压缩，裁剪等功能，有需要的小伙伴可以自行搜索相关教程～)\r\n主要逻辑处理完成之后我们再来看模糊样式的处理，在此就要介绍一个 css 方法 blur（）。\r\nblur() CSS方法将高斯模糊应用于输出图片。它只有一个接受一个参数blur(radius)\r\n\r\nradius 表示模糊的半径，值为length。 它定义了高斯函数的标准偏差值，即屏幕上有多少像素相互融合; 因此，较大的值会产生更多模糊。 值为0会使输入保持不变。 该值为空则为0。（来自MDN）\r\n它可以生成类似毛玻璃样式的图片，如下图：\r\n\r\n\r\n了解了这个方法之后，就让我们来愉快的玩耍（写代码）吧～\r\n我们可以给这个效果添加一个小动画，让它看起来更有意思哦～\r\n.image--not-loaded{\r\n  // fix ios 缺少重绘的问题，添加无意义的transform强制触发重绘\r\n  transform: scale(1);\r\n  filter:blur(30px);\r\n}\r\n.image--is-loaded{\r\n  // fix ios 缺少重绘的问题，添加无意义的transform强制触发重绘\r\n  transform: scale(1);\r\n  filter:blur(20px);\r\n  animation: sharpen 0.8s both;\r\n}\r\n@keyframes sharpen {\r\n  0% {\r\n    filter: blur(20px);\r\n  }\r\n  100% {\r\n    filter: blur(0px);\r\n  }\r\n}\r\n复制代码需要注意的是blur方法在ios上会出现无法正确展示的问题，查询了相关文章后发现是因为ios 缺少重绘，就是ios不会根据这个代码重新绘制页面因此不能正确展示，如果要解决这个问题只要给他加上一条没有意义的transform，强制触发重绘就可以了～～\r\n效果图如下:\r\n5571f524-1f57-43da-"}
{"title": "微信小程序简易SEO优化 ", "author": "Rolan", "time": "2020-2-26 00:31", "content": "半个月前给客户做了一个老小程序的 SEO 的初步优化计划，合计费时约 2 天左右，个中细节比较多， 这里举例两个比较重要，但是又不算难改的优化点。前端优化：跳转的 URL 可以直接打开简单可以测试为，分享出去的卡片，均可以直接打开（请务必测试是否登录，神坑）。这里牵扯到两个问题。页面渲染逻辑query 所携带的参数组件内 URL 问题第一个问题会牵扯到后端接口下发的内容，比如这样的场景：后端下发了一个列表数据，种种原因导致列表中就包含了点击列表后详情所要展示的所有内容，然后分享出去的是详情。这种情况基本是一个分享一个炸，自然微信小程序的页面爬虫也是个个 GG。这种情况就得前后端一起优化，独立一个 /x/detail 的接口，通过 id 等方式可获取详情的详情数据，并且注意，分享页务必接口设定无需登录。然后就是这个 id 之类的东西如何带进去，这就是第二个问题。有时候可能会因为一些特殊原因在 localStorage 或干脆直接挂在 getApp() 实例内存上，临时储存上个页面的 key，然后下个页面出来后在 onLoad 中拿这个 key 去使用。如果你有这个操作或者历史遗留问题，务必将其放在下个页面的 path 上，挂载在 query 后面。原因就是爬虫不会从上页面给你带内存数据，更不会验证本地缓存是否有效。第三个问题也很常见，因为小程序 SEO 中有一条是能用 navigator 则用 navigator， 而很有可能 nav 的功能被你封装在了一个组件内，常见比如 card 类组件，其本身就是一个 view（记得换成 navigator）下包含了其他元素。而点击操作之前可能是 bindtap 后根据组件携带的 item 计算出来的 path，而 item 是父级页面获取的接口 list 元素。如果出现这种情况，那么首先把组件的根 view 换成navigator，删除 bindtap 与相应事件，给 navigator 的 url 属性写上 item.url（或类似），然后在父级页面获取 list 的地方，多一个步骤，把 list 给 map 一下，或者 forEach 一下，给 list 的元素分别加上 url，这个 url 的计算在这里直接进行即可。服务端优化：使用页面路径推送能力这个就跟搜索引擎的站长提交链接地址一样，只不过这里提交的是小程序页面 path 与 query。多的不说，直接 NodeJS 代码参考下即可。function pushWeixinPages() {\r\n  // 默认起始 ID\r\n  let id = 0\r\n  // 这里放个本地文件保存上次推送的页面 ID，建议 ID 为数据库自增索引\r\n  // 本地保存是为了服务器重启不至于又来一遍\r\n  fs.readFile('./menu\\_id', async (error, menu\\_id) => {\r\n    console.log(error)\r\n    if(error) {\r\n      // 如果本地没有记录文件，则新建一个从零开始\r\n      fs.writeFileSync('./menu\\_id', '0')\r\n    } else {\r\n      id = menu\\_id.toString()\r\n      // 某页面数据库储存的数据\r\n      let push\\_sql = \\`\r\n        SELECT \\[selector\\] FROM \\[from\\] where \\[where\\] order by id;\r\n      \\`\r\n      // console.log(push\\_sql)\r\n      // 执行数据库语法，请自行封装\r\n      let ret = await util.sqlHandle(push\\_sql)\r\n      // 推送的页面数组\r\n      let pages = \\[\\]\r\n      ret.forEach(({ id }, idx) => {\r\n        // 添加每一项进数组\r\n        pages.push({\r\n          path: '/pages/detail/index',\r\n          query: \\`id=${id}\\`\r\n        })\r\n        // 最后一项的时候，本地存一下进度 ID\r\n        if(idx === ret.length - 1) {\r\n          fs.writeFileSync('./menu\\_id', menu.id)\r\n        }\r\n      })\r\n      // 获取微信 access\\_token，请自行封装\r\n      let { data } = await local.get('/wx/access\\_token')\r\n      // 推给微信\r\n      await axios.post(\\`https://api.weixin.qq.com/wxa/search/wxaapi\\_submitpages?access\\_token=${data.access\\_token}\\`, {\r\n        pages,\r\n      })\r\n      // 其他，愿意的话可以做做安全判断\r\n    }\r\n  })\r\n}其他语言参考处理即可，具体业务具体逻辑。其他优化方面顺便提一下，以下几方面：onShareAppMessage 时候配置 title 与 imagesitemapweb-view 不收录完事。"}
{"title": "源码级别高度定制小程序vant弹窗组件 ", "author": "Rolan", "time": "2020-2-26 00:33", "content": "作为从事前端开发的你肯定见过不少的弹框组件，你可曾有想过要自己实现一个弹框组件库，又或者想完全定制化的使用各种标准UI框架中的弹框组件呢？今天这篇文章将会带着你解析这一系列疑问，以vant-weapp组件库为例，从开发标准的弹窗组件使用到高度定制复合自我审美的弹窗，再到完全研究清楚vant-weapp框架弹窗组件部分源码。一、vant-weapp弹窗组件介绍vant-weapp组件库是有赞团队开发的 一款灵活简洁且美观的小程序UI组件库 ，此文将以这个组件库的用法为标准，下文提及的弹框组件均指的是此组件库中的弹框。弹框分类vant-weapp中弹框主要分为**两大类：弹出层Popup和对话框Dialog，**弹出层一般是带有背景遮罩层和内容展示区域用于在不跳转页面情况下进行详情的展示作用，对话框多数用于带有详情展示的同时还带有希望用户确认等操作。如下图所示，图左为典型的Dialog，图右为典型的Popup。注册小程序组件在使用弹框组件之前记得在小程序的app.json文件中先注册组件，详细介绍见 快速上手 ，例如注册van-popup组件代码如下：// app.json\r\n\"usingComponents\": {\r\n  \"van-popup\": \"path/to/@vant/weapp/dist/popup/index\"\r\n}\r\n复制代码在项目中实际使用如下：在本文后续分析van-dialog源码中会发现在dialog的index.json中也定义过van-popup组件，但是我们要直接实行van-popup组件必须在小程序的配置文件app.json中按照上图方式进行定义，微信小程序官网说明过 自定义组件内部的引入组件只在该组件内生效注册完组件之后，就可以直接在小程序页面中使用这里注册的自定义组件，组件名称为这里 key ，例如：。二、Popup基本用法常见用法最常见的用法就是直接使用van-popup组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是popup组件的内容，如下所示：// wxml\r\n<button bindtap=\"showPopup\">展示弹出层</button>\r\n<van-popup\r\n\tshow=\"{{ show }}\"\r\n\tposition=\"top\"\r\n\tbind:close=\"onClose\"\r\n  closeable\r\n>内容</van-popup>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: false\r\n  },\r\n  showPopup() {\r\n    this.setData({ show: true });\r\n  },\r\n  onClose() {\r\n    this.setData({ show: false });\r\n  }\r\n});\r\n复制代码重点属性分析van-popup组件可以通过position属性的五个值： center、top、right、bottom、left 来快捷的控制是从哪个位置弹出，例如：上例中的弹框从上往下弹出可以通过round属性来控制弹窗内容是否显示圆角，closeable可以决定是否显示关闭弹框的图标按钮，例如：上例中的弹窗将不显示圆角，同时显示关闭按钮各种基本的弹窗形式如下：三、Dialog对话框基本用法对话框则是在popup弹出层的基础上添加了额外的内置的标题，快速确定按钮等组件，用于消息提示、消息确认等场景，下面看看其常见用法。常规用法——带标题最常规的用法就是直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog\r\n  title=\"标题\"\r\n\tmessage=\"代码是写出来给人看的，附带能在机器上运行\"\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <image src=\"https://img.yzcdn.cn/1.jpg\" />\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码常规用法——无标题直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，不使用use-title-slot且不传递title属性，如下所示：// wxml\r\n<van-dialog\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <view class=\"message\">代码是写出来给人看的，附带能在机器上运行</view>\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码上述两种用法中的use-slot属性表示使用默认的slot（即van-dialog嵌套的wxml内容，比如此处的 ...）来作为内容输出，bind:getuserinfo等是使用的微信开发能力（即在点击确定按钮时候对调用微信平台API获取到对应的信息，此处是获取用户个人身份信息）函数式调用——confirm最常规的另一种用法就是直接使用 Dialog、Dialog.alert、Dialog.confirm 的方法快速打开弹窗组件，关闭弹框组件则通过 Dialog.close ，取消弹框的加载状态则使用 Dialog.stopLoading，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog id=\"van-dialog\">\r\nimport Dialog from 'path/to/@vant/weapp/dist/dialog/dialog';\r\n\r\n// js\r\nDialog.alert({\r\n  title: \"标题\"\r\n  message: '代码是写出来给人看的，附带能在机器上运行'\r\n}).then(() => {\r\n  // on close\r\n});\r\n\r\n复制代码这里使用函数调用一定要注意在使用van-dialog的页面的wxml中一定需要写这个来使用组件，下文在分析dialog的源码中会讲到（卖个关子），或者你可以先猜一猜:blush::blush:上面三种van-dialog的常规使用方法的效果如下：四、Dialog进阶用法下面将会提供几个作者在实战中写出的Dialog对话框组件的实战用法使用use-title-slot定制标题<van-dialog\r\n  id=\"van-dialog\"\r\n  show=\"{{ dialogShow }}\"\r\n  message=\"资质原件拍照或扫描可以不加盖公章，复印件需盖章\\n\\n如是三证合一，则无需提供税务登记证、组织机构代码证\"\r\n  message-align=\"left\"\r\n  confirm-button-text=\"知道了\"\r\n  confirm-button-color=\"#EE712F\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" class=\" merchant-dialog__title\">\r\n    <view class=\"merchant-dialog__title-text\">开户前，请准备以下资料</view>\r\n    <van-icon name=\"cross\" size=\"40rpx\" class=\"merchant-dialog__title-icon\" bindtap=\"closeDialog\" />\r\n  </view>\r\n</van-dialog>\r\n// 样式部分的代码此处省略\r\n复制代码触发弹框显示handleButtonClick1: function () {\r\n  this.setData({\r\n  \tdialogShow: true\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：use-title-slot\r\nconfirm-button-text、confirm-button-color\r\nvan-icon\r\n对应的效果如下：使用use-slot定制提示内容<van-dialog\r\n  id=\"van-dialog-2\"\r\n  use-slot\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"padding-bottom: 10px;\">\r\n    <van-icon name=\"close\" color=\"#fff\" size=\"30\" bindtap=\"closeDialog2\" />\r\n  </view>\r\n  <image class=\"image\" src=\"https://tva1.sinaimg.cn/large/0082zybply1gbylbcwm44j30rs13bdsg.jpg\" mode=\"aspectFit\"></image>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick2: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-2',\r\n    showConfirmButton: false,\r\n    closeOnClickOverlay: false,\r\n    className: 'dialog2',\r\n    width: '260px'\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：使用 use-slot 表示使用默认的slot来内容来渲染到弹框主体内容位置渲染的内容为一张图片，以此来 实现幕帘curtain效果使用 className 这个 externalClasses 来用页面样式控制组件内部样式对应效果如下：使用css变量定义主题<van-dialog\r\n  id=\"van-dialog-3\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"color: #000;\">提示</view>\r\n  <view>\r\n    <view>为了给你推荐更合适的漫展～</view>\r\n    <view>请开启定位权限～</view>\r\n  </view>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick3: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-3',\r\n    showCancelButton: true,\r\n    cancelButtonTrext: '取消',\r\n    confirmButtonText: '去设置',\r\n    cancelButtonColor: '#C46B85',\r\n    confirmButtonColor: '#C46B85',\r\n    message: '为了给你推荐更合适的漫展～\\n请开启定位权限～',\r\n    confirmButtonOpenType: 'openSetting',\r\n    width: '260px',\r\n    className: 'dialog3'\r\n  })\r\n},\r\n复制代码外部样式类.dialog-index--dialog3 {\r\n  --dialog-background-color: rgba(255,255,255,0.8);\r\n  --popup-background-color: rgba(255,255,255,0.8);\r\n  --button-default-background-color: transparent;\r\n  color: #666;\r\n}\r\n复制代码此例子如要使用了如下特性：cancelButtonColor、confirmButtonColor\r\n--dialog-background-color\r\n对应效果如下：五、开发实际场景中的弹窗组件如果你仔细看过上面中的三种自定义方式的实现代码应该也可以根据UI需求实现自己的弹窗交互效果；这里我已经基于前面提到的三种用法来开发了几个实际场景中的弹框组件：实现幕帘curtain效果实现操作权限提示提示应用升级应用使用提示这部分的可以直接去看源码 github.com/JohnieXu/va…也可以扫码这个小程序二维码查看效果六、源码分析的前置条件在看完上面几种炫酷的弹框效果后，我们还是按照惯例研究下如此强大的弹框组件的源码。在研究弹框部分源码之前有必有分析一下一套完整UI框架所需要注意的框架级别的整体架构如何使用less工程化处理样式处理样式是所有UI框架比不可忽略的核心逻辑之一，在vant-weapp中对样式的处理主要分为以下三部分；源码对应结构如下图所示，使用less的mixins复用实现主题变量控制、公共样式抽离等。主题变量在var.less文件定义了框架所用到的全部的样式控制相关的变量，其中与弹框相关的部分源码如下：// Dialog\r\n@dialog-width: 320px;\r\n@dialog-small-screen-width: 90%;\r\n@dialog-font-size: @font-size-lg;\r\n@dialog-border-radius: 16px;\r\n@dialog-background-color: @white;\r\n@dialog-header-font-weight: @font-weight-bold;\r\n@dialog-header-line-height: 24px;\r\n@dialog-header-padding-top: @padding-lg;\r\n@dialog-header-isolated-padding: @padding-lg 0;\r\n@dialog-message-padding: @padding-lg;\r\n@dialog-message-font-size: @font-size-md;\r\n@dialog-message-line-height: 20px;\r\n@dialog-message-max-height: 60vh;\r\n@dialog-has-title-message-text-color: @gray-7;\r\n@dialog-has-title-message-padding-top: @padding-sm;\r\n复制代码源码： var.less此文件中的最终会转换成 css变量 ，并非像antd、iview等网页端框架中的样式处理那样编译成变量指向的值。根据css变量作用域的特性，可以在自定义组件的外部样式类中局部覆盖样式变量来改变组件内部的样式。通用样式像清除浮动、文字省略、1像素边框等通用的样式类的处理在mixin文件夹下清除浮动.clearfix() {\r\n  &::after {\r\n    display: table;\r\n    clear: both;\r\n    content: '';\r\n  }\r\n}\r\n复制代码使用常见的after伪类来实现清除浮动文件省略.multi-ellipsis(@lines) {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  -webkit-line-clamp: @lines;\r\n  /* autoprefixer: ignore next */\r\n  -webkit-box-orient: vertical;\r\n}\r\n.ellipsis() {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n复制代码使用less的函数封装了两个处理文字省略方法：单行省略、多行省略BEM命名如何工程化的注册自定义组件微信小程序官方提供了 Component构造方法 注册自定义组件，为了结合typescript给自定义组件提供更灵活强大的组件注册器对Component进行了下面的功能封装处理封装通用组件构造方法function VantComponent<Data, Props, Methods>(\r\n  vantOptions: VantComponentOptions<\r\n    Data,\r\n    Props,\r\n    Methods,\r\n    CombinedComponentInstance<Data, Props, Methods>\r\n  > = {}\r\n): void {\r\n  const options: any = {};\r\n  mapKeys(vantOptions, options, {\r\n    data: 'data',\r\n    props: 'properties',\r\n    mixins: 'behaviors',\r\n    methods: 'methods',\r\n    beforeCreate: 'created',\r\n    created: 'attached',\r\n    mounted: 'ready',\r\n    relations: 'relations',\r\n    destroyed: 'detached',\r\n    classes: 'externalClasses'\r\n  });\r\n  const { relation } = vantOptions;\r\n  if (relation) {\r\n    makeRelation(options, vantOptions, relation);\r\n  }\r\n  // 给所有组件添加默认外部样式类custom-class\r\n  options.externalClasses = options.externalClasses || [];\r\n  options.externalClasses.push('custom-class');\r\n  // 给所有组件添加默认behaviors\r\n  options.behaviors = options.behaviors || [];\r\n  options.behaviors.push(basic);\r\n  // map field to form-field behavior\r\n  if (vantOptions.field) {\r\n    options.behaviors.push('wx://form-field');\r\n  }\r\n  // 默认启用多slot支持、组件中允许全局样式修改\r\n  options.options = {\r\n    multipleSlots: true,\r\n    addGlobalClass: true\r\n  };\r\n  // 最终使用官网构造方法构造组件\r\n  Component(options);\r\n}\r\n复制代码源码： component.tsbehaviors复用共享逻辑behaviors 是微信小程序官方用于组件复用 data、methods 等属性方法的一种方式，和vue中的 mixins 小作用一致，vant-weapp中定义的 mixins 如下图所示:其中basic是所有自定义组件都复用的一个mxin，给所有自定义的组件提供了三个方法： $emit、 set 和 getRect 。$emit 封装了 triggerEvent 方法；set 封装 setData 方法为Promise形式；getRect 采用Promise方法用查找对应节点的boundingClientRect。源码如下：// basic.ts\r\nexport const basic = Behavior({\r\n  methods: {\r\n    $emit(...args) {\r\n      this.triggerEvent(...args);\r\n    },\r\n    set(data: object, callback: Function) {\r\n      this.setData(data, callback);\r\n\r\n      return new Promise(resolve => wx.nextTick(resolve));\r\n    },\r\n    getRect(selector: string, all: boolean) {\r\n      return new Promise(resolve => {\r\n        wx.createSelectorQuery()\r\n          .in(this)[all ? 'selectAll' : 'select'](selector)\r\n          .boundingClientRect(rect => {\r\n            if (all && Array.isArray(rect) && rect.length) {\r\n              resolve(rect);\r\n            }\r\n\r\n            if (!all && rect) {\r\n              resolve(rect);\r\n            }\r\n          })\r\n          .exec();\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n复制代码源码： basic.ts生命周期命名其实生命周期如何命名到不是很重要，vant-weapp对命名进行了转换主要基于以下两个原因：开发效率 ：vant-weapp源自适用于vue的UI组件库—— vant ，命名统一转换便于现有框架的逻辑复用使用成本 ：生命周期命名向主流MVVM框架靠近减轻使用者的学习成本、框架维护成本function mapKeys(source: object, target: object, map: object) {\r\n  Object.keys(map).forEach(key => {\r\n    if (source[key]) {\r\n      target[map[key]] = source[key];\r\n    }\r\n  });\r\n}\r\nmapKeys(vantOptions, options, {\r\n  data: 'data',\r\n  props: 'properties',\r\n  mixins: 'behaviors',\r\n  methods: 'methods',\r\n  beforeCreate: 'created',\r\n  created: 'attached',\r\n  mounted: 'ready',\r\n  relations: 'relations',\r\n  destroyed: 'detached',\r\n  classes: 'externalClasses'\r\n});\r\n复制代码源码： component.ts#L24通过 mapKeys 方法对 VantComponent 中传入的生命周期函数进行了转换，转换名生命周期名称与微信小程序一致自定义组件的样式隔离微信小程序自定义组件默认样式作用域的范围是为当前组件，也就是说组件文件夹下的wxss中的样式只对该文件夹下的wxml生效（除去标签名、ID选择器）这种以组件为单位进行样式隔离的模式类似于React框架中处理的组件样式的库 styled-components组件间样式共享要在组件之前共享样式或者让自定义组件接受外部样式，可行方案有如下几种：| styleIsolation属性配置 |page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。 | styleIsolation 选项从基础库版本 2.6.5 开始支持 | | --- | --- | --- | | addGlobalClass属性配置 | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面 |小程序基础库版本 2.2.3 以上支持等价于styleIsolation: apply-sharedvant-weapp中使用的是此方案 ： addGlobalClass: 'true' ，默认的 styleIsolation: 'shared' 不生效 | | externalClasses外部样式类 | 组件的使用者可以指定这个样式类对应的外部样式名 ，对应样式名的样式在组件内部生效 |基础库 1.9.90 开始支持vant-weapp中也支持此方式推荐使用此方式来自定义vant-weapp的样式 | | class=\"~blue-text\"引用父组件样式 | 即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式 | 基础库 2.9.2 开始支持 |使用总结使用vant-weapp组件库的使用者最佳的自定义组件样式的方式是： 采用外部样式类+CSS变量，在无相关CSS变量时才用自己的样式+ !important  确保样式优先级 ，在自定义组件中使用vant-weapp的组件时候的注意事项参照 样式覆盖 。自定义组件通信方案自定义组件通信主要包括 组件参数传递 和 事件监听 ，这两个功能都是微信小程序官网提供的；参数传递是由父传到子的单向传递，而事件监听则是相应原生事件或者自定义事件。自定义事件用于对组件的事件进行封装，自定义事件机制如下：这里在van-dialog组件使用位置监听bindclick事件，最终这个事件会在van-dialog组件内部的button的tap时被触发，后面源码分析中的自定义组件的自定义事件全部采用的此种模式。七、Popup弹出层组件源码分析组件部分源码结构popup组件部分源码结构如下：组件的命名规范与微信小程序自定义组件的规范相符合（README.md为组件的使用说明文档，用于生成官网的组件文档说明）。popup组件的配置文件标识当前的index为组件，通过 using-components 引入了 van-icon 和 van-overlay 组件，在对应的wxml中可以直接使用。组件主要逻辑弹出层组件主要分类 遮盖层 和 内容层 ，内容层嵌套在遮盖层内部来确保视觉上覆盖在遮盖层之上。遮盖层及事件遮盖层通过overlay、overlayStyle等组件属性来控制其是否显示以及遮盖层的样式等，遮盖的事件有 onClickOverlay ，通过$emit触发组件的自定义事件close。onClickOverlay() {\r\n  this.$emit('click-overlay');\r\n\r\n  if (this.data.closeOnClickOverlay) {\r\n    this.$emit('close');\r\n  }\r\n}\r\n复制代码关闭按钮及事件通过closable属性决定是否显示默认的关闭按钮，也可以通过关闭图标相关属性配置更改按钮样式，关闭按钮的事件有onClickCloseIcon，通过$emit触发组件的自定义事件close。onClickCloseIcon() {\r\n  this.$emit('close');\r\n},\r\n复制代码内容分发接受一个默认的slot，其位置根据传入的 position 参数不同有 top、right、bottom、left、center 五种，根据这五种位置参数有对应的五种不同的弹出位置和动画过渡动画使用transform来实现动画效果，根据 position 参数的五种情况有五种默认动画// popup/index.less\r\n.van-bottom-enter,\r\n.van-bottom-leave-to {\r\n  transform: translate3d(0, 100%, 0);\r\n}\r\n.van-top-enter,\r\n.van-top-leave-to {\r\n  transform: translate3d(0, -100%, 0);\r\n}\r\n.van-left-enter,\r\n.van-left-leave-to {\r\n  transform: translate3d(-100%, -50%, 0);\r\n}\r\n.van-right-enter,\r\n.van-right-leave-to {\r\n  transform: translate3d(100%, -50%, 0);\r\n}\r\n复制代码同时暴露了外部样式类可以用来自定义动画，这里动画阶段划分和vue相同，分类： enter、enter-active、enter-to、leave、leave-active、leave-to// popup/index.ts\r\nVantComponent({\r\n  classes: [\r\n    'enter-class',\r\n    'enter-active-class',\r\n    'enter-to-class',\r\n    'leave-class',\r\n    'leave-active-class',\r\n    'leave-to-class'\r\n  ],\r\n  ...\r\n}\r\n复制代码八、Dialog对话框组件源码分析组件部分源码结构dialog组件部分源码结构如下：结构同popup组件，不同点在于index.json使用了 van-popup、van-button 组件，以及多了dialog.ts这个暴露API函数调用方法的文件。组件布局结构dialog组件整体基于popup组件，在其默认slot中添加了顶部标题的slot和按钮组元素，大致结构如下源码结构：// dialog/index.wxml\r\n<van-popup\r\n  show=\"{{ show }}\"\r\n  ...\r\n>\r\n  <view\r\n    wx:if=\"{{ title || useTitleSlot  }}\"\r\n    class=\"van-dialog__header {{ message || useSlot ? '' : 'van-dialog--isolated' }}\"\r\n  >\r\n    <slot wx:if=\"{{ useTitleSlot }}\" name=\"title\" />\r\n    <block wx:elif=\"{{ title }}\"> {{ title }}</block>\r\n  </view>\r\n\r\n  <slot wx:if=\"{{ useSlot }}\" />\r\n  <view\r\n    wx:elif=\"{{ message }}\"\r\n    class=\"van-dialog__message {{ title ? 'van-dialog__message--has-title' : '' }} {{ messageAlign ? 'van-dialog__message--' + messageAlign : '' }}\"\r\n  >\r\n    <text class=\"van-dialog__message-text\">{{ message }}</text>\r\n  </view>\r\n\r\n  <view class=\"van-hairline--top van-dialog__footer\">\r\n    <van-button\r\n      wx:if=\"{{ showCancelButton }}\"\r\n      ...\r\n    >\r\n      {{ cancelButtonText }}\r\n    </van-button>\r\n    <van-button\r\n      wx:if=\"{{ showConfirmButton }}\"\r\n      ...\r\n    >\r\n      {{ confirmButtonText }}\r\n    </van-button>\r\n  </view>\r\n</van-popup>\r\n复制代码函数式调用实现在前面中通过Dialog函数调用来打开弹出框组件，实现函数式调用的核心思路主要是： 通过selectComponent(selector)方法查找（类似于查找DOM、Vue中查找组件实例）对页面中定义渲染好的dialog组件，手动更新其组件实例的数据。 ** Dialog方法定义如下：const Dialog: Dialog = options => {\r\n  options = {\r\n    ...Dialog.currentOptions,\r\n    ...options\r\n  };\r\n  return new Promise((resolve, reject) => {\r\n    const context = options.context || getContext();\r\n    const dialog = context.selectComponent(options.selector);\r\n    delete options.context;\r\n    delete options.selector;\r\n    if (dialog) {\r\n      dialog.setData({\r\n        onCancel: reject,\r\n        onConfirm: resolve,\r\n        ...options\r\n      });\r\n      queue.push(dialog);\r\n    } else {\r\n      console.warn('未找到 van-dialog 节点，请确认 selector 及 context 是否正确');\r\n    }\r\n  });\r\n};\r\n复制代码**函数式调用时候根据传入的options配置去更新找到的组件实例上的属性由微信小程序自定义组件限制不能更新slot，slot需要用组件嵌套来传入函数式调用中的options会有默认值强制覆盖掉van-dialog组件属性处传入的非id等其他属性，即函数调用的时通过组件传入的属性无效**Dialog.confirm确认弹窗调用方法Dialog.confirm({\r\n\tselector: '#van-dialog',\r\n\ttitle: '提示',\r\n\tmessage: '这里放置提示内容'\r\n})\r\n复制代码实现方式Dialog.confirm = options =>\r\n  Dialog({\r\n    showCancelButton: true,\r\n    ...options\r\n  });\r\n复制代码调用Dialog时候默认执行定了显示取消按钮，其他无区别Dialog.close关闭弹窗调用方法Dialog.close()\r\n复制代码实现方式Dialog.close = () => {\r\n  queue.forEach(dialog => {\r\n    dialog.close();\r\n  });\r\n  queue = [];\r\n};\r\n复制代码遍历内部缓存的所有调用Dialog方法找到的van-dialog组件实例，执行其close方法Dialog.setDefaultOptions更改对话框默认配置调用方法Dialog.setDefaultOptions(options)\r\n复制代码实现方式Object.assign(Dialog.currentOptions, options);\r\n复制代码通过Object.assign将传入的默认配置合并到内部Dialog.currentOptions配置上Dialog.resetDefaultOptions恢复对话框默认配置调用方法Dialog.resetDefaultOptions()\r\n复制代码实现方式Dialog.resetDefaultOptions = () => {\r\n  Dialog.currentOptions = { ...Dialog.defaultOptions };\r\n};\r\n复制代码恢复Dialog.currentOptions配置为Dialog.defaultOptions总结本文讲解了vant-weapp组件库中的弹框组件的基本用法、进阶用法、定制主题、自定义内容等用法，同时还更进一步的研究了vant-weapp组件中的popup组件、dialog组件的实现。也只有彻底弄懂了UI框架的封装思路我们才能更进一步的修改框架来定制化更复杂更贴合项目要求的各种组件，本文按照 由实用到进阶再到研究源码 的思路为各位研究框架源码提供另一种方法。下一步将会在vant-weapp弹框组件之上封装一系列实战的案例，期待你的关注与收藏。若此文对你有一点点帮助请点个赞鼓励下作者，毕竟原创不易:)首发自语雀： www.yuque.com/johniexu/fr…作者博客地址： blog.lessing.online/作者github： github.com/johniexu"}
{"title": "小程序-日历签到 ", "author": "Rolan", "time": "2020-2-26 00:43", "content": "看小效果哈\r\n\r\n首先，我们要获取的无非就是每一个格子里面的数据。\r\n先获取月，然后点击月切换到另一个月，到了边界线的时候到了上/下年即可。\r\n那么，怎么获取月的数据呢，可以看到月第一天都是1开始，然后xx天，比如1月31天，我们把它枚举出来。\r\n但是月份受到年份影响，所以计算是否闰年就完成了。\r\n上代码\r\n获取这个月的7*5列表\r\nlet getMothList = (year, month) => {\r\n    var star = new Date(Date.UTC(year, month - 1, 1)).getDay()\r\n    let mn = getMothNum(year)[month - 1]\r\n    var res = []\r\n    var row = []\r\n    new Array(35)\r\n        .fill('')\r\n        .map((_, i) => i - star + 1)\r\n        .map(e => \r\n            (e > 0 && e <= mn)\r\n            ? ({\r\n                date: `${year}/${month}/${e}`,\r\n                number: e \r\n            })\r\n            : (null)\r\n        )\r\n        .forEach((item, i) => {\r\n            row.push(JSON.parse(JSON.stringify(item)))\r\n            if((i + 1) % 7 == 0){\r\n                res.push(row)\r\n                row = []\r\n            }\r\n        })\r\n    return res\r\n}\r\n复制代码然后获取月\r\nvar getMaxY = y =>  Boolean(\r\n\ty % 4 ==0 && y % 100 != 0 || y % 400==0\r\n)\r\nvar getAugNum = n => getMaxY(n) ? 29 : 28\r\n// --获取年对应的月份\r\nvar getMothNum = y => ([ 31, getAugNum(y), 31, 30,  31, 30, 31,31, 30, 31, 30, 31 ])\r\n复制代码我上面js就这些了（还差上下月切换的没说哈）\r\n但是少了中文的月份，有需要的这个可以再匹配\r\nvar mothZh = ['一','二','三','四','五','六','七','八','九','十','十一','十二'].map(e => e + '月')\r\n复制代码然后就是上下月月份了\r\n\r\n  up(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '上'){\r\n      if(this.data.dateM > 1){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM - 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY - 1, 12)\r\n      }\r\n    }\r\n  },\r\n  down(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '下'){\r\n      if(this.data.dateM < 12){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM + 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY + 1, 1)\r\n      }\r\n    }\r\n  },\r\n复制代码上下月操作好了就是更新数据了，更新数据的时候，因为小程序不能在view里面写逻辑，所以我们在mpa里面操作（这是我的业务逻辑，你们不用管他，我之所以放出来是方便大家查看）\r\n  setDate(dateY, dateM){\r\n    var date_list = getMothList(dateY, dateM)\r\n    .map(e => !e ? e : e.map(day => {\r\n      var cat_date = this.data.cat_date\r\n      return !day ? day : {\r\n        ...day,\r\n        className: this.data.chckin_list.indexOf(day.date) != -1 ? 'checkin' : '',\r\n        sign: day.date == [cat_date.y, cat_date.m, cat_date.d].join('/'),\r\n        maxToday: +(Date.UTC(day.date.split('/')[0], day.date.split('/')[1] - 1, +(day.date.split('/')[2])))\r\n          > Date.UTC(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()),\r\n      }\r\n    }))\r\n    this.setData(({\r\n      dateY,\r\n      dateM,\r\n      date_list,\r\n    }))\r\n    // 获取月和修改的时候，获取签到列表\r\n    this.setSign(dateY, dateM)\r\n    // console.log(date_list)\r\n  },\r\n复制代码然后会注意到，这里有一个chckin_list，这个就是要渲染出来的啦。\r\nview\r\n<view class=\"week\">\r\n            <view class=\"flex\" wx:for=\"{{date_list}}\" wx:key=\"index\" wx:for-item=\"row\">\r\n                <view \r\n                class=\"day {{day.maxToday ? 'maxToday' : ''}}\" \r\n                wx:for=\"{{row}}\" wx:for-index=\"row_idx\" wx:for-item=\"day\" wx:key=\"row_idx\"\r\n                bind:tap=\"tapDay\"\r\n                data-day=\"{{day.date}}\"\r\n                >\r\n                    <block wx:if=\"{{day}}\">\r\n                        <text class=\"block to_day_block  {{day.sign ? 'select_date' : ''}}\" wx:if=\"{{toDay == day.date}}\">今</text>\r\n                        <text class=\"block  {{day.sign ? 'select_date' : ''}}\" wx:else>{{day.number}}</text>\r\n                    </block>\r\n                    <view wx:if=\"{{day.className}}\" class=\"{{day.className}}\">已签</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n复制代码上面是我的业务逻辑，其实只需要if，day就行了，因为除了空的，其他都需要渲染。但是一般业务也有是否签到啊，今天以后的灰色不可点击啊（这里没有不可点击是因为用css禁用点击）\r\n其他\r\n之所以没放css，大家css还是自己写吧，如果真有需要，在下面评论。\r\n哦， 如果要看效果，去小程序里面搜索，《初九背单词》，点击日历（一个是首页完成今日任务，一个是我的->背单词天数）\r\n（如果有需要，我可以说下签到后台是怎么做的，nodejs）\r\n--好了--\r\n就这样了，晚安"}
{"title": "写了一个小程序——无聊也是一种生产力 ", "author": "Rolan", "time": "2020-2-27 00:34", "content": "​无聊也是一种生产力，最近不止无聊，还心烦，这种情况我只会做三种事情会比较开心，和某人出去玩、打游戏或者是写代码，前两种由于现实情况没办法实现，我就只能采用第三种方法了，并且这种时候写代码总可以写点自己想做的东西。小程序，很久之前写了一个非常简单的，当时就觉得微信小程序原生的语法真是的太复杂限制太多还不好用，尤其像我这种人，做出来的东西真的是丑的要死。这一次当然不会从头来了，果断 GitHub 找一找，不出所料，找到了我想做的东西的模板，甚至更应该说找到了还算不错的项目，Gitter，这是一个号称最漂亮的 GitHub 微信小程序，我表示同意，但是用着用着，发现其实有一点问题，无法满足我的需求：他的项目中 README 显示直接宕机了，不能显示 README 了，这个影响有点大，后来我看代码，猜测的原因是他把 markdown 的解析放到了服务器上，服务器挂掉了或者什么其他原因吧。打开小程序显示的就是 GitHub Trending，这个功能不错，但是在 Trending 中找到感兴趣的项目效率其实还是有点低的，很多时候我进去是看最近最火的现象级的项目是什么，比如 996.ICU，wuhan2020 这种，这个需求没有得到很好的满足。用这个小程序提 issue 的时候会自动加上一个小尾巴，内容是 Gitter 小程序的二维码，这个功能可以让使用者帮忙推广 小程序，没问题也是不错的方法，但是如果在一个 issue 下反复评论多次出现， 就会有一点重复的感觉。总的来说，这个小程序是一个很优秀的小程序，作为学习者的我，我要向其看起，针对不能满足需求的部分，那我就自己改写吧，License 是 Apache License 2.0，改写没问题。这里不想写具体的实现代码，如果有兴趣请 点击查看 改写后的项目，这里给出两张最后的截屏效果图吧：打开小程序，你第一眼看到的可能就是最近最应该知道的一个小程序（选择依据是积极、健康、热点、具有一定进步性，人工审核），本小程序可以查看自己所 Follow 人的活动，如果感兴趣也可以很方便的 star 或 fork，也可以查找 GitHub 所有的项目或用户（Gitter 中本来是有这个支持计划的，但是不知道为什么去掉了，我在近一周的平时使用多次用到了这个功能，还是很实用的），还可以分享给朋友，也支持 在公众号中插入直接跳转到某一个项目，在本篇中前后就有两个例子 ，非常欢迎大家使用，对于小尾巴，我的做法是可选而不是强制，为我宣传，我很感激，但是仅仅作为工具不强迫你。对于 README显示前三千个字符，基本应该可以了解这个项目是用来做什么的了，如果想查看全文可以到 Code 中查看，也是格式化好的，但是这样做就可以放在本地，并且有很好的效率，网络下载成功后几乎不用等待，我认为这样是一个比较好的用户体验。其他的界面我也都做了很多的相应优化，一些小细节，希望可以让你使用起来觉得还不错吧。开始这个项目时，由于我对小程序的写法，尤其是 Taro（本项目使用的一个框架）是从完全没听过的状态开始这个项目的，因此参考拷贝了大量的 Gitter 中代码，本项目是对 Gitter 项目的拙劣模仿。特此感谢！Gitter 项目可点击查看： Gitter后记：每次闲下来无聊我都会围绕 GitHub 学东西，这一次自我感觉是写关于 GitHub 最成功的一次了，原因也是因为这次时间最长，无聊就是生产力呀！武汉加油！中国加油！首发自公众号： RAIS"}
{"title": "玩转微信小程序的位置授权 ", "author": "Rolan", "time": "2020-2-27 00:52", "content": "背景\r\n日渐增多的小程序需求，必然会存在形色各异的授权问题。今天就来跟大家一起学习一下如何玩转小程序的位置授权\r\n位置授权问题分类\r\n\r\n并非必须允许授权：在第一次用户决策完成后都允许用户继续操作（并非完全依赖位置信息）\r\n必须允许授权：只有授权才能使用（依赖位置信息的wx小程序）\r\n\r\n分类剖析\r\n1.针对需求分类1的情况，在这里就不多说，直接调用wx.getLocation就可以\r\n2.只有授权才能继续使用的情况\r\n\r\n\r\nApp:用于描述整体程序，需要对应用添加地理位置授权，代码如下App({\r\n    config: {\r\n        'permission': {\r\n          'scope.userLocation': {\r\n            'desc': '请开启位置授权' // 高速公路行驶持续后台定位\r\n          }\r\n        },\r\n    }\r\n})\r\n复制代码\r\nPage: 处理位置信息的页面或者区域\r\nwx.getLocation: 不多讲解，是小程序的api，使用方法以及实现效果如下 Page({\r\n     onLoad () {\r\n         wx.getLocation({\r\n             success: (res) => {}, // 成功的回调\r\n             fail: (err) => {} // 失败的回调\r\n         })\r\n     }\r\n })\r\n复制代码\r\n\r\n\r\n\r\n\r\n$invoke('LocationAuthModal', showModal): 通过对LocationAuthModal组件中的方法直接调用，在页面中弹出提示弹窗，效果如下（LocationAuthModal组件是我们自定义的弹窗，并且在页面中引用）\r\n\r\n\r\n\r\nButton(open-type=”openSetting”  bindopensetting=callback): 小程序基础库2.3.0版本开始，用户发生点击行为后，才可以跳转打开setting页面，管理设置授权信息。在完成设置后，在callback中获取到授权auth进行处理：\r\n<button  open-type=\"openSetting\" @opensetting=\"callback\">设置</button>\r\n复制代码\r\n\r\ncallback: 设置完成后的回调函数\r\n\r\n\r\nsetting: 小程序的设置\r\n\r\n\r\nauth: 设置完成后获取到的设置授权信息\r\n\r\n\r\nauth[“scope.userLocation”] = true：开启了位置授权的设置，可以直接通过wx.getLocation拿到位置信息\r\n\r\n\r\nelse: 仍未开启位置授权，那么根据我们的需求是不能继续让用户使用的，所以会继续执行$invoke('LocationAuthModal', showModal)，强制提醒用户开启位置授权\r\n\r\n\r\nsuceeCallback: 成功获取位置后的回调函数，用来处理获取到微信知悉后的操作\r\n\r\n\r\n说明\r\n\r\n文档中的部分代码采用微信小程序框架--wepy\r\n开发过程中使用小程序基础库版本为v2.10.1"}
{"title": "控制音频文件播放进度 ", "author": "Rolan", "time": "2020-2-28 00:02", "content": "问题描述在微信小程序中经常会用到控制文件播放的滑块，通过滑块可控制音频播放进度，下面即用代码实现。解决方案首先用.wxml与.wmss代码实现进度条的效果，再通过.js文件控制进度条的进度和进度条的时间显示。.wxml中(播放进度结构的代码)：<view class=\"content-play-progress\">  <text>{{play.currentTime}}</text>    <view>      <slider activeColor=\"#d33a31\" block-size=\"12\" backgroundColor=\"#dadada\" value=\"{{play.percent}}\"/>    </view>  <text>{{play.duration}}</text></view>在上述代码中，第五行用到了slider组件，其值为播放进度play.percent。.wxss中(播放进度样式的代码):.content-play-progress{  display: flex;  align-items: center;  margin: 0 35rpx;  font-size: 9pt;  text-align: center;}.content-play-progress>view{  flex: 1;}保存上述代码后，运行程序，效果如图：图 1 微信小程序进度条的实现.js中(控制进度条的进度和时间的代码):onReady: function(){  this.audioCtx=wx.createInnerAudioContext()  var that=this//播放失败检测this. audioCtx.onError(function(){    console.log(‘播放失败：’+that.audioCtx.src)})//播放完成自动换下一曲this. audioCtx.OnEnded(function(){  that.next()})//自动更新播放进度this. audioCtx.onPlay(function(){this. audioCtx.onTimeUpdate(function(){  that.setData({‘play.duration’: formatTime(that.audioCtx.duration),‘play.currrentTime’: formatTime(that.audioCtx. currrentTime),‘play.percent’: that.audioCtx. currrentTime /            that.audioCtx.duration*100})})//默认选择第一曲 This.setMusic(0)  //格式化时间function formatTime(time){   var minute=Math.floor(time/60)%60;var second=Math.floor(time)%60return (minute<10?’0’+minute:minute)+’:’+     (second<10?’0’+second:second)}})}上述代码中，通过调用audioCtx的onTimeUpdate()的方法，获取音视频状态信息，并通过formatTime()函数处理时间格式，最后渲染到页面实现实时更新效果，效果如图：图 2 微信小程序进度条的滑动在slider组件上绑定bindchange事件，可以实现滑动进度条调节音视频文件播放进度，代码示例:<slider bindchange=”sliderChange” activeColor=”#d33a31” block-size=”12” backgroundColor=”#dadada” value=”{{play.percent}}”/ >在.js文件中编写sliderChange函数获取用户当前选择的进度，将时间通过audioCtx对象的seek()方法进行设置，代码示例：sliderChange: function(e){  var second=e.detail.value* that.audioCtx.duration/100that.audioCtx.seek(secend)},"}
{"title": "这次一定彻底弄懂DOM事件机制 ", "author": "Rolan", "time": "2020-2-28 00:32", "content": "本文首发自 JohnieXu's Blog ，转载请注明出处:grin:前言在网页端、移动端H5、小程序等各个终端环境的前端开发中随处可见事件的运用，可见事件机制的是前端这一块的重中之重。经过我研读了大量博客文章以及开源框架源码后，这次算是对DOM事件机制有了更新更全面的的认识。下文主要通过一个例子带你 分析DOM事件的传递、事件处理 ，然后在此基础上再 深入总结对事件监听的优化方案 ，最终总结下DOM事件机制 在开源框架中的实战应用 。一、从实例看事件传递以下面这个普通的html文件为例<!DOCTYPE html>\r\n<html lang=\"en\" onclick=\"handleClickHtml()\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Document</title>\r\n</head>\r\n<body onclick=\"handleBodyClick()\">\r\n  <div id=\"div1\" onclick=\"handleClick2()\">\r\n    <button id=\"button1\" onclick=\"handleClick1()\">handleClick1</button>\r\n  </div>\r\n  <script>\r\n    function handleClick1(e) {\r\n      console.log('click1')\r\n    }\r\n    function handleClick2(e) {\r\n      console.log('click2')\r\n    }\r\n    function handleBodyClick(e) {\r\n      console.log('body clicked')\r\n    }\r\n    function handleClickHtml(e) {\r\n      console.log('html clicked')\r\n    }\r\n    document.addEventListener('click', e => {\r\n      console.log('document clicked')\r\n    })\r\n  </script>\r\n</body>\r\n</html>\r\n复制代码例子中给 document、html、body、div、button 都添加了点击事件，其执行结果如下：执行结果事件传递事件产生后，从window对象自上而下向目标节点传递，抵达目标节点后会沿着相反方向传递DOM事件传递事件传递路径如何确定？由鼠标、键盘、触摸屏、窗口缩放、图片加载、节点焦点变化等触发事件，每个触发的事件都有一个target——事件目标，根据target往html根节点遍历就可以确定节点嵌套层级关系，从而确定此事件的传递路径。事件传递路径由浏览器、webview来确定事件传递为何要来回走两遍？一个事件来回走两遍是便于事件响应时机的控制（下文的事件冒泡与事件捕获的应用中有体现），同时也存在事件冒泡的浏览器历史原因（与IE、Netscape有关，不赘述）。事件响应事件在从自上而下的传递过程中会 判断当前node节点是否绑定对应事件的监听器 ，若有则执行响应监听器的事件处理程序（也就是绑定的事件要执行的逻辑），这里的执行就是所谓的事件响应。事件的响应过于与事件的类型是捕获事件、冒泡事件有关，同时是否组件冒泡还会影响该事件的后续传递过程，具体执行流程总结成如下图所示：事件响应逻辑事件捕获与冒泡根据事件传递中的两种传递路径分别分为： 由上至下——事件捕获阶段，由下至上——事件冒泡阶段 ，指的是一个事件由window（上图并未标出window）到target之间的传递的过程。可以通过组织事件冒泡让事件不再继续完成由下至上的过程，这会让target的父节点绑定冒泡阶段的事件监听器不响应事件。可以通过指定事件在捕获阶段执行。:chestnut:冒泡的应用看下面这个例子，可以通过 stopPropagation 来阻止事件继续往上冒泡， window、document、html 上添加的点击事件均不会生效<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  var div1 = document.getElementById('div1')\r\n  var button1 = document.getElementById('button1')\r\n  div1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n  }, false)\r\n  button1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n    e.stopPropagation() // 关键代码：组织了click事件继续往上冒泡\r\n  }, false)\r\n复制代码// 以下是监听html、document的点击事件 function handleClickHtml(e) { console.log('html clicked') } document.addEventListener('click', e => { console.log('document clicked') }) </script> 复制代码点击button的打印结果如下：执行结果addEventListener需要用attachEvent进行兼容性处理，第三个参数默认值为false表示在事件冒泡阶段响应事件:chestnut:捕获的应用还是上面这个例子，只更改div1部分的事件监听，的第三个参数为true来开启事件捕获<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  var div1 = document.getElementById('div1')\r\n  var button1 = document.getElementById('button1')\r\n  div1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n  }, true) // true：表示div1在事件的捕获阶段响应事件\r\n  button1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n    e.stopPropagation() // 组织事件冒泡\r\n  }, false)\r\n复制代码// 以下是监听html、document的点击事件 function handleClickHtml(e) { console.log('html clicked') } document.addEventListener('click', e => { console.log('document clicked') }) </script> 复制代码点击button的打印结果如下：执行结果依次执行了div1和button1绑定的点击事件，注意这里两者的 执行顺序 很关键。事件在捕获阶段遇到div1节点时执行打印，然后在button处（处于目标阶段）执行打印，然后事件被阻止冒泡不再往上传递。二、事件性能优化大批量事件监听性能问题考虑以下场景：有个一个长消息列表实时接受新的消息，滚动到底部时加载更多消息，点击消息可进入回话窗口页面，消息左滑消息此条消息问题：如何给此消息列表添加左滑事件？抽象来看这个问题就是如何高效的给大批量（甚至是无限量）节点添加事件，这里暂时不考虑vue、react等框架性能问题原因每注册一个事件监听监听都需要使用一定内存，同时在dom节点多了之后事件经过的捕获、冒泡阶段要处理事件传递也就慢了事件委托父节点嵌套的子节点的触发的事件会通过事件冒泡到达父节点，事件处理程序不直接绑定到子节点，统一由公共父节点进行事件监听。e.target表示触发事件的元素，通过e.target可以判断具体响应那个元素的事件 e.currentTarget表示事件绑定的元素，在事件委托情况下指向同一个元素事件委托采用事件委托改造本文例子<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  document.addEventListener('click', e => {\r\n    // e.target：触发事件的元素\r\n    // e.currentTarget：事件监听器绑定的元素\r\n    // console.log(e.target, e.currentTarget)\r\n    if (e.target.id === 'button1') {\r\n      return console.log('button1 clicked')\r\n    }\r\n    if (e.target.id === 'div1') {\r\n      return console.log('div1 clicked')\r\n    }\r\n    if (e.target.tagName === 'HTML') {\r\n      return console.log('html clicked')\r\n    }\r\n    if (e.target.tagName === 'BODY') {\r\n      return cosnole.log('body clicked')\r\n    }\r\n  })\r\n</script>\r\n复制代码依次点击 html、div1、button1 会依次打印结果：执行结果虚拟滚动上面事件委托可以解决大批量节点事件监听的性能问题，但是DOM节点量过大导致界面滚动不流畅的问题没解决。虚拟滚动是指在列表滚动事件中动态计算出当前窗口中能够显示的列表节点，其前后窗口不显示的节点各用一个div进行占位处理，并调整占位div的样式确模拟的列表样式与原始列表无异处。虚拟滚动已经是一个完美解决长列表渲染性能的方案，针对react、vue均有对应库实现，此处不再赘述React事件代理事件委托也叫事件代理，在react中的合成事件则是完全采用了事件代理基于react16的 ant-design-pro 项目的事件绑定截图如下：React事件代理直接通过onClick绑定的事件通过react处理最终会统一绑定到document上，正是使用的事件委托。三、实战中的应用小程序中阻止事件冒泡阻止弹窗滚动穿透最新版微信小程序中绑定事件有两种类型： bind:methodName、catch:methodName、mut-bind:methodName、mut-catch:methodName ，其中区别最大的是前两者。methodName表示移动端事件名，例如：tap、touchmove等bind:methodName 采用冒泡绑定事件， catch:methodName **采用冒泡绑定事件并阻止冒泡vant-weapp中防止滚动穿透实现思路： 弹框采用一层遮罩层overlay遮盖，遮罩层宽高设为窗口宽高同大小，采用 catch:touchmove 绑定该层的touchmove事件为空函数防止其冒泡 。给overlay组件外层绑定touchmove为空函数并阻止冒泡：// overlay/index.wxml\r\n<van-transition\r\n  show=\"{{ show }}\"\r\n  custom-class=\"van-overlay\"\r\n  custom-style=\"z-index: {{ zIndex }}; {{ customStyle }}\"\r\n  duration=\"{{ duration }}\"\r\n  bind:tap=\"onClick\"\r\n  catch:touchmove=\"noop\"\r\n  /*\r\n   * 通过catch:touchmove来阻止冒泡至overlay层的事件继续往上冒泡，\r\n   * 实现内层嵌套的内容可以响应touchmove事件而外层（页面）滚动事件不响应），\r\n   * 以此来解决滚动事件穿透\r\n  */\r\n>\r\n  <slot></slot>\r\n</van-transition>\r\n复制代码overlay组件外层fixed定位固定宽高防止滚动：// overlay/index.less\r\n.van-overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  .theme(background-color, '@overlay-background-color');\r\n}\r\n复制代码移动端H5框架中事件冒泡阻止弹窗滚动穿透vant中防止滚动穿透实现思路：与vant-weapp小程序框架中相似， 弹框采用一层遮罩层overlay遮盖，遮罩层宽高设为窗口宽高同大小，采用 @touchmove 绑定该层的touchmove事件，在事件中用event.stopPropagation阻止事件冒泡 。给overlay组件外层绑定touchmove事件阻止冒泡：return (\r\n  <transition name=\"van-fade\">\r\n    <div\r\n      vShow={props.show}\r\n      style={style}\r\n      class={[bem(), props.className]}\r\n      onTouchmove={preventTouchMove}\r\n      {...inherit(ctx, true)}\r\n    />\r\n  </transition>\r\n);\r\n复制代码const preventTouchMove(e: Event): void = () =&gt; { event.stopPropagation(); } <span>复制代码</span>overlay组件外层fixed定位固定宽高防止滚动：.van-overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  .theme(background-color, '@overlay-background-color');\r\n}\r\n复制代码参考文章MDN-事件参考浪里行舟-DOM事件机制CSDN-事件冒泡（IE事件流），事件捕获和DOM事件流写在最后既然看到这里不妨点个赞鼓励下作者呗 :)作者博客： blog.lessing.online/作者github： github.com/johniexu"}
{"title": "小程序订阅消息用户拒绝/关闭后，如何引导用户再开启？并获得用户的操作呢？ ... ", "author": "Rolan", "time": "2020-3-5 00:15", "content": "前言有些时间没折腾小程序了，话说年前小程序就发布了消息，于1月10日会下线模板消息下发功能，所有的订阅消息都要用户手动触发确认同意，这可就太难了，之前的\twx.openSetting 、\twx.getPhoneNumber 、\twx.getUserInfo 等等API的调整，可把我折腾惨了，这次又来……难道直接js调用，不爽吗？非要整手动确认，爽是肯定的，但如果从一个用户的角度出发，自己啥都没干，你就把我信息获取了、天天给我推一堆垃圾信息，那肯定不爽了，所以从这角度看，微信的调整也是为了尊重用户的隐私，毕竟用户第一嘛今天主要是想分享一下，今天在处理这个订阅消息逻辑时，遇到当\t用户拒绝 后，如何重新引导开启 「订阅消息」通知的问题，并在\t开启后获取到它的状态如果你处理过小程序的订阅消息，应该是知道的，在用户拒绝或关闭消息总开关之后，我们引导用户手动开启「订阅消息」功能（也就是\topenSetting API的调用回调里，是拿不到\tscope.subscribeMessage 状态的），开始我也纠结了很久，百度、google都用上了，同样发现很多的同学也有遇到这样的问题，而都没有找到解决方案，最后在我快要放弃的时候却突然灵光一闪，想到了个办法，所以抖胆BB几句，分析一下：温馨提示：书读的少，却又喜欢瞎BB几句，内容仅为个人解决方案的思路，仅供参考，不足之处请见谅，勿喷，谢谢～授权API示例首先来看下调用的示例：wx.requestSubscribeMessage({\r\n  tmplIds: ['模版id'],\r\n  success (res) {\r\n\r\n  }\r\n})同时官方也说了，\tsuccess 回调的模版对应有三种状态：accept = 同意reject = 拒绝ban = 后台封禁fail 也有对应的状态码，如下：本次要讲的是\terrorCode 20004 与\treject 状态时，根据以往经验，如果拒绝了，我们肯定是使用直接使用\topenSetting ,引导用户进行手动开启授权（），比如：//以微信运动为例\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  components = {\r\n    Toast: Toast,\r\n    Modals: Modals\r\n  };\r\n  methods = {\r\n  };\r\n  data = {\r\n    signHistory: []\r\n  };\r\n  getRunData() {\r\n    wx.getWeRunData({\r\n      success: res => {\r\n        ……处理运动步数逻辑\r\n      }\r\n    });\r\n  }\r\n  setAuth() {\r\n    wx.getSetting({\r\n      success: res => {\r\n        //第一步，检测是否有授权 - 没有授权\r\n        if (!res.authSetting['scope.werun']) {\r\n          //第二步，开始授权，但这里有一个坑点（腾讯的bug），之前授权过但是是拒绝，所以会进入失败\r\n          wx.authorize({\r\n            scope: 'scope.werun',\r\n            success: () => {\r\n              this.getRunData();\r\n            },\r\n            fail: () => {\r\n              //第三步，引导用户，手动引导用户点击按钮，去设置页开启，## Modals是自定义组件\r\n              this.$invoke('Modals', '__modalConfirm__', [\r\n                '检测到您没有打微信运动的权限，是否去设置？',\r\n                'openSetting',\r\n                //第四步，进入设置页的回调 - 成功\r\n                res => {\r\n                  let { authSetting } = res.detail;\r\n                  if (authSetting['scope.werun']) {\r\n                    this.getRunData();\r\n                  } else {\r\n                    this.$invoke('Toast', '__warning__', [\r\n                      `您没有同意授权微信运动，获取步数失败`\r\n                    ]);\r\n                  }\r\n                },\r\n                //第五步，点击取消按钮的回调\r\n                () => {\r\n                  this.$invoke('Toast', '__warning__', [\r\n                    `您已拒绝微信运动授权，无法获取步数`\r\n                  ]);\r\n                }\r\n              ]);\r\n            }\r\n          });\r\n        } else {\r\n          //第六步，已经授权直接进入保存逻辑\r\n          // console.log(\"授权了\")\r\n          this.getRunData();\r\n        }\r\n      }\r\n    });\r\n  }\r\n}上面代码执行截图如下：上述代码，\tthis.$invoke('Modals'……) 部分为自定义弹窗，即引用用户确定，去设置页，requestSubscribeMessage 问题点但是 在\topenSetting 的回调里，是没有\tscope.subscribeMessage 这一项的，下面是列出的\tscope 列表 官方清单（\t文档地址 ）：//提交订阅消息示例\r\n\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            //发起请求……\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n\r\n          // 20004:用户关闭了主开关 或在 消息通知 里 “拒绝接收”操作，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        //但是这个回调数据里，并没有 「订阅消息」 相关 open/close 的状态返回\r\n\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约`\r\n        ]);\r\n      }\r\n    ]);\r\n}上图为\topenSetting 的回调数据，而网上说回调里不做任何处理，用户是否有手动开启，则让提示让他再手动点击一次业务按钮，如果有开启，则回到最初的逻辑，订阅消息成功，否则则又循环进入\topenSetting 设置页，俗称“死缠烂打授权法”，这当然不失为一种方法，但体验不是最好，对于追求完美的我来说，不能接受，继续寻找更好的方案，把官方文档来回看，终于发现了新大陆，——\twx.getSetting文档有有这么一个属性：\tsubscriptionsSetting ，感谢苍天，终于让我看到了\t订阅消息 相关的东西，//官方示例\r\nwx.getSetting({\r\n  withSubscriptions: true,\r\n  success (res) {\r\n    console.log(res.authSetting)\r\n    // res.authSetting = {\r\n    //   \"scope.userInfo\": true,\r\n    //   \"scope.userLocation\": true\r\n    // }\r\n    console.log(res.subscriptionsSetting)\r\n    // res.subscriptionsSetting = {\r\n    //   mainSwitch: true, // 订阅消息总开关\r\n    //   itemSettings: {   // 每一项开关\r\n    //     SYS_MSG_TYPE_INTERACTIVE: 'accept', // 小游戏系统订阅消息\r\n    //     SYS_MSG_TYPE_RANK: 'accept'\r\n    //     zun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject', // 普通一次性订阅消息\r\n    //     ke_OZC_66gZxALLcsuI7ilCJSP2OJ2vWo2ooUPpkWrw: 'ban',\r\n    //   }\r\n    // }\r\n  }\r\n})在\twx.getSetting 的回调里，有一项\tmainSwitch ，还有一项\twithSubscriptions: true ，最后回调里还能一项\tzun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject' ，到这里，但它也只是在\tgetSetting 方法里啊，跟\topenSetting 没有扯上任何关系，怎么办？其实道理很简单，但人有时候就是这样，思维如果没有转换过来，你可以就会一直杠在那个死胡同里出不来，openSetting 回调里取不到状态，\t那么我们是否可以在它的回调里，再做一次\tgetSetting 的调用里呢？\t，取\tgetSetting 回调里的状态来判断，刚才用户在设置页的行为操作，直接看示例吧：//提交订阅消息示例\r\n\r\nconst pushReservationTmplIds = 'PVC_DBcvvdtffd1fO0vdS8YpSe0c7Br3QW54';\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  submitClock() {\r\n    fetchJson({\r\n      type: 'POST',\r\n      url: '/api/steps/clock',\r\n      data: {\r\n      },\r\n      success: res => {\r\n        wx.showToast({\r\n          title: '预定成功',\r\n          icon: 'success',\r\n          duration: 2000\r\n        });\r\n      }\r\n    });\r\n  }\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            that.submitClock();\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            // console.log(res, '0 拒绝 or 关闭了订阅消息的主（总）开关---');\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n          // 20004:用户关闭了主开关，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            // console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n            that.guideOpenSubscribeMessage();\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guidSubscribeMessageAuthAfter() {\r\n    //引导用户 开启订阅消息 之后，「openSetting」 接口暂时不会返回，用户手动设置后的状态，所以采用「getSetting」接口重新进行查询\r\n    wx.getSetting({\r\n      withSubscriptions: true,\r\n      success: res => {\r\n        let {\r\n          authSetting = {},\r\n          subscriptionsSetting: { mainSwitch = false, itemSettings = {} } = {}\r\n        } = res;\r\n\r\n        if (\r\n          (authSetting['scope.subscribeMessage'] || mainSwitch) &&\r\n          itemSettings[pushReservationTmplIds] === 'accept'\r\n        ) {\r\n          this.submitClock();\r\n          // console.log('用户手动开启同意了，订阅消息');\r\n        } else {\r\n          this.$invoke('Toast', '__warning__', [\r\n            `您没有同意授权订阅消息，预约领取失败`\r\n          ]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      //用户点击了确定按钮，进入设置页的回调\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        this.guidSubscribeMessageAuthAfter();\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约领取`\r\n        ]);\r\n      }\r\n    ]);\r\n  }\r\n}结尾到这里，\twx.requestSubscribeMessage 的问题，也就得到了解决，看到网上有贴子在喷\trequestSubscribeMessage API的设计，比如：\twx.requestSubscribeMessage的接口参数结构设计反人性，实习生设计的吗？ ,其实我也想说这么庞大的一个生态体系，更新方案就考虑的这么不全面吗？还是说就是这么反人类？\tgetSetting 里给\trequestSubscribeMessage 的相关状态，\topenSetting 里又压根没有，然后又把它的引导开启逻辑UI也放在设置页里面，我就郁闷了，今天的分享，为我个人的解决思路方案，如有不足之处，请指出，勿喷～谢谢！！"}
{"title": "全平台（Vue、React、微信小程序）任意角度旋转 图片裁剪组件 ... ", "author": "Rolan", "time": "2020-3-5 00:34", "content": "SimpleCrop 目前是 全网唯一 支持裁剪图片任意角度旋转、交互体验 媲美原生客户端 的 全平台 图片裁剪组件。项目地址： github.com/newbieYoung… 。特性及优势和目前流行的图片裁剪组件相比，其优势在于以下几点：裁剪图片支持任意角度旋转；支持 Script 标签、微信小程序、React、Vue 等多种开发模式；支持移动和 PC 设备；支持边界判断、当裁剪框里出现空白时，图片自动吸附至完全填满裁剪框；移动端缩放以双指中心为基准点；交互体验媲美原生客户端。示例微信小程序示例移动端示例左侧是 IOS 系统相册中原生的图片裁剪功能，右侧为 SimpleCrop 移动端示例。可以扫描二维码体验：或者访问以下链接：newbieyoung.github.io/Simple-Crop…PC 示例链接如下：newbieyoung.github.io/Simple-Crop…关键实现要实现 任意角度旋转 、 双指中心缩放 、 边界判断 、 自动吸附 等功能，关键点如下：1、屏幕坐标系和变换基准点在裁剪图片场景中，存在两个坐标系，其一是裁剪图片所代表的实际尺寸坐标系，其二是裁剪框显示到屏幕上所代表的屏幕坐标系；后续进行 transform 变换计算和位置判断时，为了计算方便，需要把裁剪图片的尺寸以及位置从实际坐标系转换为屏幕坐标系。另外当对裁剪图片进行 transform 变换时，变换基准点默认为其中心点，对应 CSS 的 transform-origin 为 50% 50%。2、获取实时坐标首先需要实时获取裁剪图片进行 CSS Transform 变换后的新坐标，只有在实时获取变换后的新坐标的前提下才能结合裁剪框坐标进行越界、吸附等判断；在计算 CSS Transform 变换后的新坐标时需要注意选取的屏幕坐标系和 CSS Transform 坐标系的差别，比如示例中以黑色边框中心为坐标原点，水平向左为 X 轴正方向，垂直向上为 Y 轴正方向；但是 CSS Transform 的坐标系垂直向下为 Y 轴正方向和上述规定的坐标系 Y 轴正方向是相反的，因此在获取 CSS Transform 变换矩阵之后求实时坐标时还需要进行镜像变换。详细计算过程可以查看 CSS3 2D Transform Matrix 。3、旋转适配缩放裁剪图片任意角度旋转时需要进行适当的放大才能保证裁剪框不超出，因此就需要先计算裁剪框哪些点超出，然后根据超出的点计算刚好包含的放大倍数。当两个矩形位置关系任意变换时计算相互之间有哪些点超出有两种方案：其一：图中左侧红色矩形代表裁剪图片，黑色矩形代表裁剪框，如图所示裁剪框顶点 A 超出了裁剪图片。连接矩形四个顶点和判断点，然后计算四条连线之间的夹角，如果夹角之和小于 360 度，那么该判断点在矩形外；反之如果夹角之和等于 360 度，那么该判断点在矩形内。a1 + a2 + a3 + a4 < 360\r\nb1 + b2 + b3 + b4 = 360\r\n复制代码其二：图中黑色矩形表示裁剪图片，点 A 表示裁剪框中超出裁剪图片的某个顶点。连接矩形中心点和判断点，然后计算中心点和判断点向量在矩形边框向量上的投影长度（L1、L2），只要两个投影长度中有任意投影长度大于其投影边框长度（H1、H2）的一半即说明该点在矩形外。另外还可以根据投影长度和其投影边框长度的比例计算出矩形恰好包含该点的放大系数，也就是示例图中的 S 变量。最后旋转图片时除了要进行适当的放大，保证裁剪框不超出以外，还可以在裁剪图片中心点没有变动时进行适当的缩小，去掉多余间隙，进一步提升交互体验。缩小系数的计算原理和放大系数的计算原理类似，均是连接判断点和中心点，然后根据边框投影长度计算。大矩形为裁剪图片，小矩形表示裁剪框，O 表示裁剪图片中心点。4、双指中心位移由于默认裁剪图片的变换基准点为其中心点，这么处理虽然计算方便，但是会对双指缩放造成一定的困难；因为双指操作时双指中心并不一定是裁剪图片中心。解决方案需要先求出两个不同基准点的位移差，然后在进行缩放变换之后再进行位移变换。5、缩放适配变换在旋转裁剪图片时可以对其进行适当得放大和缩小从而保证裁剪框不会超出裁剪图片；但是在双指操作缩放裁剪图片却不能这么做，因为适配缩放会和用户的操作缩放冲突，因此需要采用移动裁剪图片的方式保证裁剪框不超出裁剪图片。当裁剪图片进行位移变换之后可以包含裁剪框，就只需要计算位移向量；红色矩形为裁剪图片，黑色矩形为裁剪框。但是还有一种情况即裁剪图片进行位移变换之后不能包含裁剪框，如下：红色实线矩形为裁剪图片，黑色矩形为裁剪框，红色虚线矩形为进行放大之后恰好包含裁剪框的裁剪图片。此时说明用户的操作缩放超出了组件的合法限制范围，可以加入适配缩放了；这时候就需要先计算裁剪图片恰好包含裁剪框的放大系数，然后再进行位移变换。"}
{"title": "微信小程序上传图片至OSS的一些个人总结 ", "author": "Rolan", "time": "2020-3-5 00:42", "content": "这两天修改公司小程序的一些功能，发现上传图片至OSS失败，便一直寻找出现了什么问题，最后发现是policy过期，更改后发现相应的signature也要改，因为需要特定的处理才能生成signature，当时好一顿查资料，最后算出signature，在这里做一下总结，也借签了一位作者的文章。 https://segmentfault.com/a/11...首先，准备工作:1.下载Base64.js,hmac.js,sha1.js,crypto.js相关算法 点击 。2.创建一个用于计算的policy和signa的js文件，我们只要输出结果即可。我们起名为ceshi.js。3.在ceshi.js引入我们下载的4个算法文件。const Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');一、先转码Policy在ceshi.jslet date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));使用此js可计算出一个policy二、计算signatureconst accesskey = 'QSZ***98V1DW'; // 为了保密我做了处理，大家输入自己公司的accesskey即可。\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64, accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);这样我们便可计算出signature啦。三、全部代码为ceshi.jsconst Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');\r\nfunction myfunc() {\r\n  let date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  console.log(srcT);\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));\r\n  const accesskey = 'QSZYryqudf8AAzyoAoJbeCIP98V1DW';\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64,    accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);\r\n}\r\nmodule.exports.myfunc = myfunc;四、调用ceshi.js新建oss.jsconst ceshi = require('./ceshi.js');\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function (options) {\r\n    ceshi.myfunc();\r\n  },\r\n  onReady: function () {\r\n  },\r\n  onShow: function () {\r\n  },\r\n  onHide: function () {\r\n  },\r\n  onUnload: function () {\r\n  },\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n  onReachBottom: function () {\r\n  },\r\n  onShareAppMessage: function () {\r\n\r\n  }\r\n})五、文件目录六、结果以上是全部内容，感谢之前看过的相似文章，在此我自己做了相关总结，希望能帮大家解决问题！谢谢！"}
{"title": "京东购物小程序cookie方案实践 ", "author": "Rolan", "time": "2020-1-13 00:32", "content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信小程序没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了 数据缓存 Storage 和 网络 Network 这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以 在这里 找到，阅读本文时配合实践，效果更佳。二、浏览器中的cookie为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：本地存储：浏览器会在本地分配一块空间，存储cookie请求携带：每次发起请求，都会从本地取出cookie并追加在请求头上响应设置：当响应头有Set-Cookie字段时，需要解析并更新过期时间：每个cookie字段有单独的过期时间，并且到期会自动清除读写操作：暴露API给前端JS调用，可进行增删改查操作作用域：路径path、域名domin编码：cookie值，在网络传输需要encode，建议存储也一样其它：HttpOnly、Secure、SameSite在浏览器的 DevTools 中，可以看到当前站点下的Cookie明细：三、小程序中的cookie实现方案设计在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。本地存储小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的 LocalStorage ），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个 cookies 字段进行存储：// 存：\r\nwx.setStorageSync('cookies', cookies)\r\n// 取：\r\nwx.getStorageSync('cookies')\r\n复制代码其中 cookies 的「存储结构」如下：// cookies = \r\n{\r\n    cookie1: { // “最小cookie单元” ==> cookieItem\r\n        name: 'cookie1', // cookie名\r\n        value: 'xxx',    // cookie值\r\n        expires: 'Fri, 17 Jan 2020 08:49:41 GMT' // 过期时间，使用GMT（格林威治标准时间）格式\r\n    }\r\n},\r\n复制代码上面的 cookie1 便是一个“最小cookie单元 cookieItem ”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的 Storage 选项卡，可以查看本地存储的情况：读写操作这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie———— getCookie()步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：function getCookie(name = '') {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let { value, expires } = cookies[name] || {}\r\n\r\n    return (name && expires && !isExpired(expires)) ? decodeURIComponent(cookieItem.value) : ''\r\n}\r\n复制代码2. 设置cookie———— setCookie()步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：设置单个/多个cookie直接传值/传cookieItem（Object）时间格式maxAge/expires调用示例如下：setCookie({\r\n    cookie1: 12345,\r\n    cookie2: '12345'\r\n})\r\n\r\nsetCookie({\r\n    cookie1: {\r\n        value: 12345,\r\n        maxAge: 3600 * 24  // 自定义有效期（这里示例是24小时）\r\n    },\r\n    cookie2: {\r\n        value: '12345',\r\n        expires: 'Wed, 21 Oct 2015 07:28:00 GMT' // 标准GMT格式\r\n    }\r\n})\r\n复制代码这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取 name/value/expires/maxAge ，传给格式化函数转为标准的 cookieItem ：function setCookie(cookiesParam) {\r\n    let oldCookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let newCookies = {} // 由 cookiesParam 转化为标准格式后的cookies\r\n\r\n    for (let name in cookiesParam) {\r\n        if (isObject(cookiesParam[name])) { // 传入是Object格式\r\n            let { value, expires, maxAge } = cookiesParam[name]\r\n            // 转换为标准cookie格式（cookieItem）\r\n            newCookies[name] = getStandardCookieItem({ name, value, expires, maxAge })\r\n        } else {\r\n            newCookies[name] = getStandardCookieItem({ name, value: cookiesParam[name] })\r\n        }\r\n    }\r\n\r\n    // 同步到本地Storage\r\n    saveCookiesToStorage(Object.assign({}, oldCookies, newCookies))\r\n}\r\n复制代码3. 删除cookie———— removeCookie()步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storagefunction removeCookie(cookieName) {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n\r\n    delete cookies[cookieName]\r\n\r\n    saveCookiesToStorage(Object.assign({}, cookies))\r\n}\r\n复制代码四、Cookie 在网络中的传递本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：Set-Cookie\r\nCookie\r\nCookie\r\n以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式： HTTP 和 WebSocket ，这里以HTTP为例，先对请求api进行「封装」：function requestPro({ url, data, header, method = 'GET' }) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url,\r\n            data,\r\n            header: Object.assign({}, { 'Cookie': CookieLib.getCookiesStr() }, header), // 请求头————带上Cookie\r\n            success (res) {\r\n              let { data : resData, header, statusCode } = res\r\n              let setCookieStr = header['Set-Cookie'] || header['set-cookie'] || ''\r\n\r\n              CookieLib.setCookieFromHeader(setCookieStr) // 响应头————解析Set-Cookie\r\n              resolve(resData)\r\n            },\r\n            fail (err) {\r\n                reject(err)\r\n            }\r\n          })\r\n    })\r\n}\r\n复制代码如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：1. 请求携带步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到 Request Header 中上面代码中的 getCookiesStr() 直接取cookies拼接即可，返回示例： cookie1=xxx;cookie2=yyy 。2. 响应设置步骤：（每次收到响应后）解析 Response Header 的 Set-Cookie 字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理 Set-Cookie 内容时，有几个点需要留意： - 最基本的格式： Set-Cookie: <cookie-name>=<cookie-value> - 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。3. 编码问题「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅 RFC6265 发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].\r\n“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过 encode 编码后保存下来，所以直接取到的也是 encode 后的值，所以追加在请求头 Cookie 字段，就不需要 decode 解码了，直接拼接即可（但基础库API的get操作最终需要进行 decode 解码）。而对于响应头 Set-Cookie 的值，我们认为后端已经做了 encode 编码，所以前端不需要处理，直接存进 Storage 即可。五、性能优化（高频读写）前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。1. 初始化首先需要在内存中声明一个 _COOKIES （命名自行diy），建议在cookie基础库中声明，便于统一维护。2. 读前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的 _COOKIES 即可。3. 写写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。六、单元测试微信官方在2019年5月推出了「小程序自动化 SDK」 miniprogram-automator ，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：小程序全局范围的cookie验证（比如初始化小程序后，有没有种下版本号、访问行为等关键cookie）cookie基础库API验证（比如get/set/remove等各个API是否正常工作）以验证 setCookie() API为例：it('API验证：setCookie()', async () => {\r\n    await miniProgram.evaluate(() => {\r\n        wx.CookieLib.setCookie({ // 调用API\r\n            cookie1: 12345,\r\n        })\r\n    })\r\n\r\n    let { cookies } = await miniProgram.callWxMethod('getStorageSync', 'cookies')\r\n    expect(cookies['cookie1'].value).toBe(12345) // 期望成功设置cookie1为12345\r\n})\r\n复制代码这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了 wx 对象上，实现方式是使用node读写文件的API去【植入代码】：fs.appendFileSync('./your_project/app.js', ''\\n wx.CookieUtil = require(\\'./lib/cookie.js\\');\\n'')\r\n复制代码七、Cookie安全Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。path、domin、HttpOnly、Secure、SameSite小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此 path、domin、HttpOnly、Secure、SameSite 这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。白名单机制前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。前端防篡改小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个 _Cookies ，如果有一个API getAllCookies() 直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。SessionSession机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。指纹上报用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。八、完整小程序实现Demo代码片段： developers.weixin.qq.com/s/x4sFASmh7…九、小结本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。"}
{"title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... ", "author": "Rolan", "time": "2020-1-13 00:58", "content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于 uni-app 框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的小程序的制作思路和实现代码。目录1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验1、完整源码链接：完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。2、实现思路该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用 canvasToTempFilePath 转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用 canvasToTempFilePath 转成图片导出。3、核心代码3-1、文字/图片编辑模块文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。HTML<img\r\n style=\"position: absolute\"\r\n :style=\"{\r\n     left: item.x+'px', \r\n     top: item.y+'px',\r\n     width: item.w+'px',\r\n     height: item.h+'px',\r\n     }\"\r\n  @touchstart='touchStart($event,item,index)' \r\n  @longpress='longPress($event,item,index)'\r\n  @touchmove.stop='touchMove($event,item,index)' \r\n  @touchcancel=\"touchEnd($event,item,index)\" \r\n  @touchend='touchEnd($event,item,index)'\r\n  v-for=\"(item,index) of imagelist\"\r\n  :key=\"index\" \r\n  :src=\"item.src\"\r\n  />在 imageList 的数组标签中，每个绑定的事件中用 $event 来调用事件本身的参数，其中 $event 的 touches 或 changedTouches 包含我们需要的位置参数，示例如下：touches:[{\r\n        clientX: 14 //与显示区域(不含顶部栏)左上角的水平距离\r\n        clientY: 16 //与显示区域(不含顶部栏)左上角的垂直距离\r\n        pageX: 14 //与整个页面(不含顶部栏)左上角的水平距离\r\n        pageY: 16 //与整个页面(不含顶部栏)左上角的垂直距离\r\n        },\r\n        {\r\n        clientX: 14\r\n        clientY: 16\r\n        pageX: 14\r\n        pageY: 16\r\n        }]touches 长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为 style=\"position: absolute\" 所以只需要根据位置参数来更新 x、y、w、h 即可题外话-性能问题一次移动多次操作DOM影响性能—— 虚拟DOM了解一下为何不用事件委派—— 不必要，Vue已经帮我们做了优化，在非常影响性能时再考虑图片编辑Demo3-2、油墨电子签名板由于 touchmove 事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。HTML<canvas \r\ncanvas-id=\"canvas\" \r\n@touchstart.stop=\"touchStart\" \r\n@touchmove.stop=\"touchMove\"\r\n@touchend.stop=\"touchEnd\"\r\n>\r\n</canvas>JAVASCRIPTexport default {\r\ndata() {\r\n    return {\r\n        lineWidth0: 5, //初始线宽 建议1~5\r\n        ctx: null,\r\n        x0: 0, //初始横坐标或上一段touchmove事件中触摸点的横坐标\r\n        y0: 0, //初始纵坐标或上一段touchmove事件中触摸点的纵坐标\r\n        t0: 0, //初始时间或上一段touchmove事件发生时间\r\n        v0: 0, //初始速率或touchmove事件间发生速率\r\n        lineWidth: 0, //动态线宽\r\n        keenness: 5, //油墨程度 建议0~5\r\n        k: 0.3, //油墨因子，即每次绘制线条时线宽的变化程度\r\n    }\r\n},\r\nonReady() {\r\n    this.ctx = uni.createCanvasContext('canvas', this);\r\n    this.ctx.setLineCap('round')\r\n},\r\nmethods: {\r\n    //设置初始值\r\n    touchStart(e) {\r\n        this.lineWidth = this.lineWidth0\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = 0\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n    },\r\n\r\n    touchMove(e) {\r\n        let dx = e.touches[0].clientX - this.x0,\r\n            dy = e.touches[0].clientY - this.y0,\r\n            ds = Math.pow(dx * dx + dy * dy, 0.5),\r\n            dt = (new Date().getTime()) - this.t0,\r\n            v1 = ds / dt; //同 this.v0 初始速率或touchmove事件间发生速率\r\n        if (this.keenness === 0) { //油墨为0时\r\n            this.ctx.moveTo(this.x0, this.y0)\r\n            this.ctx.lineTo(this.x0 + dx, this.y0 + dy)\r\n            this.ctx.setLineWidth(this.lineWidth)\r\n            this.ctx.stroke()\r\n            this.ctx.draw(true)\r\n        } else {\r\n            //由于touchMove的触发频率问题，这里采用for循环绘制，原理如图所示\r\n            //这里的k因为\r\n            let a = this.keenness\r\n            if (this.keenness > 5) {\r\n                a = 5\r\n            }\r\n            for (let i = 0; i < a; i++) {\r\n                this.ctx.moveTo(this.x0 + dx * i / a, this.y0 + dy * i / a)\r\n                this.ctx.lineTo(this.x0 + dx * (i + 1) / a, this.y0 + dy * (i + 1) / a)\r\n                //此时touchmove事件间发生与上一个事件的发生的速率比较\r\n                if (v1 < this.v0) {\r\n                    this.lineWidth -= this.k\r\n                    if (this.lineWidth < this.lineWidth * 0.25) this.lineWidth = this.lineWidth * 0.25\r\n                } else {\r\n                    this.lineWidth += this.k\r\n                    if (this.lineWidth > this.lineWidth * 1.5) this.lineWidth = this.lineWidth * 1.5\r\n                }\r\n                this.ctx.setLineWidth(this.lineWidth)\r\n                this.ctx.stroke()\r\n                this.ctx.draw(true)\r\n            }\r\n        }\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = v1\r\n    },\r\n    touchEnd(e) {\r\n        this.x0 = 0\r\n        this.y0 = 0\r\n        this.t0 = 0\r\n        this.v0 = 0\r\n    }\r\n}\r\n}使用的大部分是canvas的基础api，注意绘制单位都为px。油墨电子签名Demo3-3、开放式海报模块如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——鲁迅说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。HTML<canvas canvas-id=\"generate\" :style=\"{ width: canvasW + 'rpx', height: canvasH + 'rpx'}\"></canvas>相关介绍spread 语法async 函数如果图片是网络路径，记得获取临时路径。//别忘了在函数前加 async\r\nlet src = 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg'\r\nsrc = (await uni.getImageInfo({src}))[1].path;JAVASCRIPT输出字段部分//为方便设置，以下除角度外，单位均以rpx为主\r\ndata() {\r\n    return {\r\n        canvasW:720,\r\n        canvasH:1000,\r\n        img:[{\r\n            src: 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg',\r\n            x: 0,\r\n            y: 0,\r\n            w: 100,\r\n            h: 100,\r\n            r: 50,//圆角度\r\n            degrees: 30,//旋转度\r\n            mirror: true//是否镜像\r\n            }],\r\n        text:[{\r\n                content: 'TensionMax',\r\n                x: 50,\r\n                y: 50,\r\n                w: 100,\r\n                lineHeight: 35,//行间距\r\n                color: '#000000',\r\n                size: 28,\r\n                weight: 'normal',//字体粗细\r\n                lineThrough: true,//是否贯穿\r\n            }],\r\n        ctx: null,\r\n        k: null //单位转换因子\r\n    };\r\n}JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法px2rpx() {\r\n    //当转换的参数只有一个时直接返回数值如\r\n    //当不为一个时返回数组，然后用spread语法将其展开为几个参数\r\n    //Math.floor()是为了防止在安卓机上造成的数据紊乱，开发者工具无此bug\r\n    if (arguments.length === 1) return Math.floor(arguments[0] / this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i / this.k))\r\n    }\r\n    return params\r\n},\r\nrpx2px() {\r\n    if (arguments.length === 1) return Math.floor(arguments[0] * this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i * this.k))\r\n    }\r\n    return params\r\n},JAVASCRIPT绘制图片的函数async drawImg() {\r\nthis.ctx.setFillStyle('#FFFFFF')\r\nthis.ctx.fillRect(0, 0, ...this.rpx2px(this.canvasW, this.canvasH)) //绘制背景\r\nfor (let i of this.img) { //for循环绘制图片\r\n    i.src = (await uni.getImageInfo({src: i.src}))[1].path;//获取图片临时路径\r\n    this.ctx.save() //保存当前绘制内容\r\n    if (i.mirror) { //如果设置镜像\r\n        //因为canvas的translate属性是基于原点（初始原点为右上角）变化\r\n        //所以需要先将原点移动至图片中心，变化后再还原\r\n        //旋转变化同理\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.scale(-1, 1)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    if (i.degrees) { //如果设置旋转\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.rotate(i.degrees * Math.PI / 180)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    this.radiusRect(...this.rpx2px(i.x, i.y, i.w, i.h, i.r)) //圆角或矩形路径绘制\r\n    this.ctx.clip() //裁剪\r\n    this.ctx.drawImage(i.src, ...this.rpx2px(i.x, i.y, i.w, i.h))\r\n    this.ctx.restore() //恢复非裁剪区域\r\n}\r\nthis.ctx.draw(true) \r\n}\r\n\r\nradiusRect(x, y, w, h, r) {\r\n    if (r > w / 2 || r > h / 2) {\r\n        r = Math.min(w, h) / 2\r\n    }\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x, y); // 将操作点移至左上角\r\n    this.ctx.arcTo(x + w, y, x + w, y + r, r); // 画右上角的弧\r\n    this.ctx.lineTo(x + w, y) //可省略，但由于安卓真机的小程序bug，留之，下同。\r\n    this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r); // 画右下角的弧\r\n    this.ctx.lineTo(x + w, y + h) //可省略\r\n    this.ctx.arcTo(x, y + h, x, y + h - r, r); // 画左下角的弧\r\n    this.ctx.lineTo(x, y + h) //可省略\r\n    this.ctx.arcTo(x, y, x + r, y, r); // 画左上角的弧\r\n    this.ctx.lineTo(x, y) //可省略\r\n},绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。开放式海报Demo3-4、小结既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过 props 、 sync 修饰符 等来实现父子通信，当然如果想做更复杂的可以考虑用 Vuex 传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。4、效果展示效果图如下，如果由什么疑问欢迎到下方评论区讨论。"}
{"title": "小程序、H5登录授权、分享、支付流程 ", "author": "Rolan", "time": "2020-1-14 00:32", "content": "前言对于前端来说，微信的 支付 、 分享 、 登录 是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：域名相关知识介绍该网站不安全，请不要输入密码\r\n微信小程序授权登录流程op=>operation: openid判断是否登录授权\r\nop2=>operation: 根据wx.login获取code\r\nop3=>operation: 调用服务端根据code换取openid\r\nop4=>operation: 通过用户授权，获取信息，存到数据库\r\nop->op2->op3->op4\r\n复制代码如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：服务端官方文档 客户端文档nodejs + 小程序实现授权登录前端部分根据本地是否有userId判断是否登录，如果没有登录，则获取用户的openidonLoad() {\r\n   if(!this.data.userId) {\r\n       this.getSession()\r\n   }\r\n},\r\n getSession() {\r\n   wx.login({\r\n     success: (res) => {\r\n       if (res.code) {\r\n         app.get(Api.getSession, {\r\n           code: res.code\r\n         }).then(res => {\r\n           store.setItem('openid', res.openid)\r\n         })\r\n       }\r\n     }\r\n   })\r\n }复制代码点击授权按钮，发起登录请求。getUserInfo(e) {\r\n    let userInfo = e.detail.userInfo;\r\n    userInfo.openid = store.getItem('openid')\r\n    app.get(Api.login, {\r\n        userInfo\r\n    }).then(res => {\r\n        store.setItem('userId', res.data.userId)\r\n        this.setData({\r\n            userId: res.userId\r\n        })\r\n    })\r\n}复制代码服务端部分在 config 里面，定义公用的 appid 和 appsecretmodule.exports = {\r\n    wx: {\r\n        appId: 'wx0ef10432747d8f57',\r\n        appsecret: 'cc47a6127687e999a1dffa756ff83c0e'\r\n    },\r\n    mp: {\r\n        appId: 'wx0691f1dcf6e5e231',\r\n        appSecret: 'c7ed875e338120f15f49476a6596eb4f'\r\n    }\r\n}复制代码然后通过调用小程序 官方文档 的接口，获取到 appid 传给客户端let express = require('express');\r\nlet router = express.Router();\r\nlet request = require('request');\r\nlet config = require('./config');\r\nlet uril = require('./../../util/index')\r\nconfig = Object.assign({}, config.mp);\r\n\r\nrouter.get('/getSession', (req, res) => {\r\n    let code = req.query.code\r\n    if (!code) {\r\n        res.json(uril.handleFail('code不能为空', 10001))\r\n    }\r\n    let sessionUrl = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.appId}&secret=${config.appSecret}&js_code=${code}&grant_type=authorization_code`;\r\n    request(sessionUrl, (err, response, body) => {\r\n        let result = util.handleResponse(err, response, body)\r\n        res.json(result)\r\n    })\r\n})复制代码登录接口 的编写// 小程序授权登录\r\nrouter.get('/login',async function(req,res){\r\n  let userInfo = JSON.parse(req.query.userInfo);\r\n  if (!userInfo){\r\n    // 如果接口没有信息，则返回错误信息\r\n    res.json(util.handleFail('用户信息不能为空',10002))\r\n  }else{\r\n    // 查询当前用户是否已经注册\r\n    let userRes = await dao.query({ openid: userInfo.openid},'users_mp');\r\n    if (userRes.code == 0){\r\n      // 如果已经注册，直接把查出来的信息返回给客户端\r\n      if (userRes.data.length >0){\r\n        res.json(util.handleSuc({\r\n          userId: userRes.data[0]._id\r\n        }))\r\n      }else{\r\n        // 如果这个用户之前没有注册，则在数据库插入用户信息\r\n        let insertData = await dao.insert(userInfo,'users_mp');\r\n        if (insertData.code == 0){\r\n          let result = await dao.query({ openid: userInfo.openid }, 'users_mp');\r\n          res.json(util.handleSuc({\r\n            userId: result.data[0]._id\r\n          }))\r\n        }else{\r\n          res.json(insertData);\r\n        }\r\n      }\r\n    }else{\r\n      res.json(userRes);\r\n    }\r\n  }\r\n})复制代码上述代码的 handleFail 和 handleResponse 是封装的对数据的统一处理，如果有兴趣，参见 github 地址。这里不展示代码。需要注意的是，这种实现方式，获取 openid 的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权和分享流程H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。 官方文档 给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。mounted(){\r\n   this.checkUserAuth();\r\n },\r\nmethods:{\r\n// 检查用户是否授权过\r\ncheckUserAuth(){\r\n  let openId = this.$cookie.get('openId');\r\n  if(!openId){\r\n    // 如果没有登录授权，则跳转到微信提供的跳转页面。\r\n    window.location.href = API.wechatRedirect;\r\n  }else{\r\n  // 如果用户已经授权，则调用获取微信配置信息接口\r\n    this.getWechatConfig();\r\n  }\r\n},复制代码API.wechatRedirect:wechatRedirect:'/api/wechat/redirect?url=http%3A%2F%2Fm.51purse.com%2F%23%2Findex&scope=snsapi_userinfo',复制代码「注意」url地址需要 encodeURIComponent 编码才可以。m.51purse.com 需要与你在微信公众号后台配置的 授权域名 一致！nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的 接口// 用户授权重定向\r\nrouter.get('/redirect',function (req,res) {\r\n  let redirectUrl = req.query.url, scope = req.query.scope, callback = 'http://m.51purse.com/api/wechat/getOpenId';\r\n  cache.put('redirectUrl', redirectUrl);\r\n  // 获取到客户端带过来的数据，请求微信接口\r\n  let authorizeUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${config.appId}&redirect_uri=${callback}&response_type=code&scope=${scope}&state=STATE#wechat_redirect`;\r\n  res.redirect(authorizeUrl);\r\n})\r\n复制代码当用户点击 确认授权 之后，会执行跳转 callbacl：http://m.51purse.com/api/wechat/getOpenId 。而这个接口也是node端实现的，具体内容如下：// 用code换取access_token的方法\r\nexports.getAccessToken = function(code){\r\n  let token_url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${config.appId}&secret=${config.appSecret}&code=${code}&grant_type=authorization_code`;\r\n  return new Promise((resolve, reject) => {\r\n    request.get(token_url, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  });\r\n}\r\n\r\n\r\n// 根据code获取用户的OpenId\r\nrouter.get('/getOpenId',async function(req,res){\r\n  let code = req.query.code;\r\n  console.log(\"code:\"+code);\r\n  if(!code){\r\n    res.json(util.handleFail('当前未获取到授权code码'));\r\n  }else{\r\n    // 用code换取access_token\r\n    let result = await common.getAccessToken(code);\r\n    if(result.code == 0){\r\n      // 换取access_token成功\r\n      let data = result.data;\r\n      let expire_time = 1000 * 60 * 60 * 2;\r\n      // 往客户端写入cookie：openId\r\n      res.cookie('openId', data.openid, { maxAge: expire_time });\r\n      let openId = data.openid;\r\n      let userRes = await dao.query({ 'openid': openId },'users');\r\n      if (userRes.code == 0){\r\n        if (userRes.data.length>0){\r\n          // 从数据库查找到用户信息后，回调到客户端的页面\r\n          let redirectUrl = cache.get('redirectUrl');\r\n          res.redirect(redirectUrl);\r\n        }else{\r\n          let userData = await common.getUserInfo(data.access_token, openId);\r\n          let insertData = await dao.insert(userData.data,'users');\r\n          if (insertData.code == 0){\r\n            // 从数据库查找到用户信息后，回调到客户端的页面\r\n            let redirectUrl = cache.get('redirectUrl');\r\n            res.redirect(redirectUrl);\r\n          }else{\r\n            // 返回错误信息\r\n            res.json(insertData);\r\n          }\r\n        }\r\n      }else{\r\n        // 返回错误信息\r\n        res.json(userRes);\r\n      }\r\n    }else{\r\n      // 返回错误信息\r\n      res.json(result);\r\n    }\r\n  }\r\n})\r\n复制代码「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。H5分享流程同样，如果你没有阅读过微信H5开发的 官方文档 ,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要 npm install wx-jssdk// 这个信息统一定义在api.js中，这里为了方便，放在前面，便于查看。\r\nAPI.wechatConfig: /api/wechat/jssdk\r\n\r\n\r\n// 获取微信配置信息\r\ngetWechatConfig(){\r\n  this.$http.get(API.wechatConfig+'?url='+location.href.split('#')[0]).then(function(response){\r\n    let res = response.data;\r\n    if(res.code == 0){\r\n      let data = res.data;\r\n      wx.config({\r\n        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\r\n        appId: data.appId, // 必填，公众号的唯一标识\r\n        timestamp: data.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: data.nonceStr, // 必填，生成签名的随机串\r\n        signature: data.signature,// 必填，签名\r\n        jsApiList: data.jsApiList // 必填，需要使用的JS接口列表\r\n      })\r\n      wx.ready(()=>{\r\n        util.initShareInfo(wx);\r\n      })\r\n    }\r\n  })\r\n}复制代码util/index.js 里面对分享的功能进行了封装。export default {\r\n  //获取浏览器地址栏参数值\r\n  getUrlParam(name){\r\n    let reg = new RegExp('(^|&)'+name+'=([^&]*)');\r\n    let r = window.location.search.substr(1).match(reg);\r\n    if(r!=null)return decodeURIComponent(r[2]);\r\n  },\r\n  initShareInfo(wx){\r\n    let shareInfo = {\r\n      title: 'xxxx', // 分享标题\r\n      desc: 'xxxx', // 分享描述\r\n      link: 'http://m.51purse.com/#/index', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致\r\n      imgUrl: '', // 分享图标\r\n    }\r\n    wx.onMenuShareAppMessage(shareInfo);\r\n    wx.onMenuShareTimeline(shareInfo);\r\n    wx.onMenuShareQQ(shareInfo);\r\n    wx.onMenuShareQZone(shareInfo);\r\n    // 下面两种方法为新的方法,上面的方法将会被淘汰。\r\n    wx.updateAppMessageShareData(shareInfo);\r\n    wx.updateTimelineShareData(shareInfo);\r\n  }\r\n}\r\n复制代码nodejs端对 /wechat/jssdk 接口的实现如下：// common.getToken()方法 获取基础接口的Token\r\n\r\nexports.getToken = function(){\r\n  let token = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${config.appId}&secret=${config.appSecret}`;\r\n  return new Promise((resolve, reject)=>{\r\n    request.get(token, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  })\r\n}\r\n----\r\n\r\nrouter.get('/jssdk',async function(req,res){\r\n  let url = req.query.url;\r\n  let result = await common.getToken();\r\n  if (result.code == 0){\r\n    let token = result.data.access_token;\r\n    let params = {\r\n      // 生成随机字符串\r\n      noncestr:util.createNonceStr(),\r\n      // 生成时间戳\r\n      timestamp:util.createTimeStamp(),\r\n      url\r\n    }\r\n      let str = util.raw(params);\r\n      console.log('str:::' + JSON.stringify(params))\r\n      let sign = createHash('sha1').update(str).digest('hex');\r\n      res.json(util.handleSuc({\r\n        appId: config.appId, // 必填，公众号的唯一标识\r\n        timestamp: params.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: params.noncestr, // 必填，生成签名的随机串\r\n        signature: sign,// 必填，签名\r\n        jsApiList: [\r\n          'updateAppMessageShareData',\r\n          'updateTimelineShareData',\r\n          'onMenuShareTimeline',\r\n          'onMenuShareAppMessage',\r\n          'onMenuShareQQ',\r\n          'onMenuShareQZone',\r\n          'chooseWXPay'\r\n        ] // 必填，需要使用的JS接口列表\r\n      }))\r\n    }\r\n  }else{\r\n    res.json(result);\r\n  }\r\n})复制代码以上代码主要获得基础的 token ,然后用基础 token 结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是， 基础token 和 accessToken 的区别。建议 参考文章 。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付小程序支付前端流程获取openId调起数字签名后端支付流程拼接常规参数生成签名拼接xml数据调用下单接口获取预支付Id：prepay_id生成支付sdk定义回调接口，接受微信支付消息支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法/**\r\n * 公共函数定义\r\n */\r\nlet createHash = require('create-hash');\r\nmodule.exports = {\r\n  // 生成随机数\r\n  createNonceStr(){\r\n    return Math.random().toString(36).substr(2,15);\r\n  },\r\n  // 生成时间戳\r\n  createTimeStamp(){\r\n    return parseInt(new Date().getTime() / 1000) + ''\r\n  },\r\n  // 生成签名\r\n  getSign(params, key){\r\n    let string = this.raw(params) + '&key=' + key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 生成系统的交易订单号\r\n  getTradeId(type='wx'){\r\n    let date = new Date().getTime().toString();\r\n    let text = '';\r\n    let possible = '0123456789';\r\n    for(let i=0;i<5;i++){\r\n      text += possible.charAt(Math.floor(Math.random() * possible.length))\r\n    }\r\n    return (type == 'wx'?'ImoocWxJuZi':'ImoocMpJuZi') + date + text;\r\n  },\r\n  // Object 转换成json并排序\r\n  raw(args){\r\n    let keys = Object.keys(args).sort();\r\n    let obj = {};\r\n    keys.forEach((key)=>{\r\n      obj[key] = args[key];\r\n    })\r\n    // {a:1,b:2} =>  &a=1&b=2\r\n    // 将对象转换为&分割的参数\r\n    let val = '';\r\n    for(let k in obj){\r\n      val += '&' + k + '=' +obj[k];\r\n    }\r\n    return val.substr(1);\r\n  }\r\n}复制代码下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的 order 方法。/**\r\n * 微信小程序、H5通用支付封装\r\n */\r\nlet config = require('./../pay/config')\r\nlet request = require('request')\r\nlet util = require('../../util/util')\r\nlet createHash = require('create-hash')\r\nlet xml = require('xml2js')\r\nconfig = config.mch;\r\nmodule.exports = {  \r\n  order: function (appid,attach, body, openid, total_fee, notify_url, ip){\r\n    return new Promise((resolve,reject)=>{\r\n      let nonce_str = util.createNonceStr();\r\n      let out_trade_no = util.getTradeId('mp');\r\n      // 支付前需要先获取支付签名\r\n      let sign = this.getPrePaySign(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no);\r\n      // 通过参数和签名组装xml数据，用以调用统一下单接口\r\n      let sendData = this.wxSendData(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no, sign);\r\n      let self = this;\r\n      let url = 'https://api.mch.weixin.qq.com/pay/unifiedorder';\r\n      request({\r\n        url,\r\n        method: 'POST',\r\n        body: sendData\r\n      }, function (err, response, body) {\r\n        if (!err && response.statusCode == 200) {\r\n          xml.parseString(body.toString('utf-8'),(error,res)=>{\r\n            if(!error){\r\n              let data = res.xml;\r\n              console.log('data:' + JSON.stringify(data));\r\n              if (data.return_code[0] == 'SUCCESS' && data.result_code[0] == 'SUCCESS'){\r\n                // 获取预支付的ID\r\n                let prepay_id = data.prepay_id || [];\r\n                let payResult = self.getPayParams(appid, prepay_id[0]);\r\n                resolve(payResult);\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(util.handleFail(err));\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 生成预支付的签名\r\n  getPrePaySign: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no) {\r\n    let params = {\r\n      appid,\r\n      attach,\r\n      body,\r\n      mch_id: config.mch_id,\r\n      nonce_str,\r\n      notify_url,\r\n      openid,\r\n      out_trade_no,\r\n      spbill_create_ip: ip,\r\n      total_fee,\r\n      trade_type: 'JSAPI'\r\n    }\r\n    let string = util.raw(params) + '&key=' + config.key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 签名成功后 ，根据参数拼接组装XML格式的数据，调用下单接口\r\n  wxSendData: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no,sign) {\r\n    let data = '<xml>' + \r\n      '<appid><![CDATA[' + appid + ']]></appid>' + \r\n      '<attach><![CDATA[' + attach + ']]></attach>' + \r\n      '<body><![CDATA[' + body + ']]></body>' + \r\n      '<mch_id><![CDATA[' + config.mch_id + ']]></mch_id>' + \r\n      '<nonce_str><![CDATA[' + nonce_str + ']]></nonce_str>' + \r\n      '<notify_url><![CDATA[' + notify_url + ']]></notify_url>' + \r\n      '<openid><![CDATA[' + openid + ']]></openid>' + \r\n      '<out_trade_no><![CDATA[' + out_trade_no + ']]></out_trade_no>' + \r\n      '<spbill_create_ip><![CDATA[' + ip + ']]></spbill_create_ip>' + \r\n      '<total_fee><![CDATA[' + total_fee + ']]></total_fee>' + \r\n      '<trade_type><![CDATA[JSAPI]]></trade_type>' + \r\n      '<sign><![CDATA['+sign+']]></sign>' + \r\n    '</xml>'\r\n    return data;\r\n  },\r\n  getPayParams:function(appId,prepay_id){\r\n    let params = {\r\n      appId,\r\n      timeStamp:util.createTimeStamp(),\r\n      nonceStr:util.createNonceStr(),\r\n      package: 'prepay_id=' + prepay_id,\r\n      signType:'MD5'\r\n    }\r\n    let paySign = util.getSign(params,config.key);\r\n    params.paySign = paySign;\r\n    return params;\r\n  }\r\n}复制代码最后定义 /pay/payWallet 的支付接口，里面调用公用的order方法。// 小程序支付\r\nrouter.get('/pay/payWallet',function(req,res){\r\n  let openId = req.query.openId;//用户的openid\r\n  let appId = config.appId;//应用的ID\r\n  let attach = \"小程序支付课程体验\";//附加数据\r\n  let body = \"欢迎学习慕课首门支付专项课程\";//支付主体内容\r\n  let total_fee = req.query.money;//支付总金额\r\n  let notify_url = \"http://localhost:3000/api/mp/pay/callback\"\r\n  let ip = \"123.57.2.144\";\r\n  wxpay.order(appId,attach,body,openId,total_fee,notify_url,ip).then((result)=>{\r\n    res.json(util.handleSuc(result));\r\n  }).catch((result)=>{\r\n    res.json(util.handleFail(result.toString()))\r\n  });\r\n})复制代码这里的流程请参见 官方描述 。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取 签名 。然后根据签名加上其他需要的 参数 (参见上述代码)再凭借xml的数据。然后再调用统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 。生成 prepay_id之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的 payWallet 接口，传入 openId 和 money 即可。然后获取到相应的参数，调用微信提供的 requestPayment 拉起支付即可。主要代码逻辑如下：pay() {\r\n    app.get(Api.payWallet,{\r\n      openId: Store.getItem('openId'),\r\n      money: this.data.index\r\n    }).then((res) => {\r\n      // 支付\r\n      wx.requestPayment({\r\n        timeStamp: res.timeStamp,\r\n        nonceStr: res.nonceStr,\r\n        package: res.package,\r\n        signType: res.signType,\r\n        paySign: res.paySign,\r\n        success: function (errmsg) {\r\n          if (errmsg == 'requestPayment:ok') {\r\n            wx.showToast({\r\n              title: '支付成功',\r\n              icon: 'success'\r\n            });\r\n          }\r\n        },\r\n        fail: function (res) {\r\n          if (res.errMsg == 'requestPayment:fail cancel') {\r\n            wx.showToast({\r\n              title: '支付取消',\r\n              icon: 'none'\r\n            });\r\n          } else {\r\n            wx.showToast({\r\n              title: res.errmsg,\r\n              icon: 'none'\r\n            });\r\n          }\r\n        }\r\n      })\r\n    });\r\n  }\r\n复制代码到这里，小程序端的支付功能就已经实现了。"}
{"title": "微信小程序加入购物车动画的实现（向上、向下） ", "author": "Rolan", "time": "2020-1-14 00:42", "content": "场景描述：一般情况下，加入购物车的动画效果都会是上图的3的路线，在这篇文章里，我们来实现1和2路线的加入购物车的动效（3路线的动画效果网上有很多，具体可以参考这篇文章来实现： www.cnblogs.com/greengage/p… ）。实现方式：不管是上图中的哪一种效果，我们都是用CSS3里的cubic-bezier（三次贝塞尔曲线）来实现的。具体什么是三次贝塞尔曲线，可以参考这篇文章： www.bbsmax.com/A/RnJWwpbRJ…#实现流程：1、获取屏幕的高度大小wx.getSystemInfo({//  获取页面的有关信息\r\n      success: function (res) {\r\n        wx.setStorageSync('systemInfo', res)\r\n        var ww = res.windowWidth;\r\n        var hh = res.windowHeight;\r\n        that.globalData.ww = ww;\r\n        that.globalData.hh = hh;\r\n      }\r\n    });\r\n复制代码2、获取点击的位置（购物车的位置我们定为最上方或者最下方），定义移动距离/*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n复制代码3、在css里调用beizer函数.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n复制代码aCartScale是，在曲线的最后，实现了个购物车抖动的动画@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n复制代码至此，流程全部介绍完毕，下面是全部的代码（里面可能有一些没用的css样式代码，读者可以自行根据需要删除）：js代码：var app = getApp();\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isFly:false\r\n  },\r\n\r\n  /*添加到购物车*/\r\n  onAddingToCartTap: function (events) {\r\n    //防止快速点击\r\n    if (this.data.isFly) {\r\n      return;\r\n    }\r\n    this._flyToCartEffect(events);\r\n  },\r\n  /*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n\r\n})\r\n复制代码wxml代码：<view class=\"container detail-container\">\r\n  <view class=\"fixed-btns-box\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n  <view \r\n  style=\"position: fixed;right: 50rpx;bottom:100rpx;width: 100rpx;\"\r\n  class=\"add-cart-btn {{product.stock==0?'disabled':''}}\" bindtap=\"onAddingToCartTap\">\r\n    <text style=\"width: 360rpx\">加入分享</text>\r\n    <image class=\"cart-icon\" src=\"../../imgs/icon/cart.png\"></image>\r\n    <image id=\"small-top-img\" class=\"small-top-img {{isFly?'animate':''}}\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575871576&di=dda9d07660c88bea6553c3279b0a8cf0&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.pc6.com%2Fup%2F2011-9%2F2011926155953.jpg\"\r\n      mode=\"aspectFill\" style=\"{{translateStyle}}\"></image>\r\n  </view>\r\n\r\n\r\n  \r\n\r\n  <view class=\"fixed-btns-box2\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n</view>\r\n复制代码wxss代码：.detail-container {\r\n  background-color:#F9F9F9\r\n}\r\n.detail-header-box,.detail-bottom-box{\r\n  background-color: #fff;\r\n}\r\n.detail-topic-img{\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.detail-topic-img image{\r\n  width: 100%;\r\n}\r\n\r\n.fixed-btns-box{\r\n  position: fixed;\r\n  top:50rpx;\r\n  right:12px;\r\n  width: 80rpx;\r\n\r\n}\r\n.fixed-btns-box2{\r\n  position: fixed;\r\n  right:12px;\r\n  width: 80rpx;\r\n  bottom: 50rpx;\r\n\r\n}\r\n.fiexd-cart image{\r\n  height: 64rpx;\r\n  width: 64rpx;\r\n}\r\n.fiexd-cart view{\r\n  font-size: 24rpx;\r\n  background-color: #AB956D;\r\n  color: white;\r\n  position: absolute;\r\n  right: 64rpx;\r\n  top: 0rpx;\r\n  height: 36rpx;\r\n  width: 36rpx;\r\n  line-height: 36rpx;\r\n  border-radius: 36rpx;\r\n  text-align: center;\r\n}\r\n.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n\r\n@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n.product-counts,.add-cart-btn{\r\n  height: 100%;\r\n  display: flex;\r\n  font-size: 24rpx;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n.product-counts{\r\n  width: 50%;\r\n}\r\n.add-cart-btn{\r\n  position: relative;\r\n  flex: 1;\r\n}\r\n.add-cart-btn:active{\r\n  color: #fff;\r\n}\r\n.add-cart-btn.disabled{\r\n  color: #D5D5DB;\r\n}\r\n\r\n\r\n\r\n.small-top-img{\r\n  height: 160rpx;\r\n  width: 160rpx;\r\n  right:6rpx;\r\n  position: absolute;\r\n  opacity: 0;\r\n}\r\n.small-top-img.animate{\r\n  opacity: 1;\r\n  -webkit-transition:all 1000ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\r\n}\r\n\r\n\r\n\r\n\r\n.add-cart-btn .cart-icon{\r\n  margin-left: 40rpx;\r\n  height: 32rpx;\r\n  width: 32rpx;\r\n}\r\n\r\n\r\n.disabled{\r\n    pointer-events: none;\r\n}\r\n\r\n复制代码"}
{"title": "我是怎么在 3 天内开发 AI 微信小程序的 ", "author": "Rolan", "time": "2020-2-5 00:32", "content": "基于对 AI 的爱好与兴趣，我走上了独自钻研机器学习的道路。和所有热爱 AI 的人们一样，在一段孤独的摸索旅程中，我勉强完成了几次深度学习模型的训练。其中令我印象较深的成果就是情感分类模型。他能够根据你的文字生成其背后作者的喜怒哀乐。深度学习模型展示出来的 \"人性化\"让我感到惊喜，于是我开始思考怎么将它的“人性化”转化为帮助人们的工具。在情感模型的基础上建立一个上层应用，让它为人类社会中增添不一样的烟火。基于多方面的考量，我最终选择开发一款 微信 \"情感\" 小程序。故事拉开序幕在进行小程序开发之前，我们非常有必要先对小程序做一个充分的了解。什么是小程序简单来说，比起传统的 App，微信小程序是一种全新的连接用户与服务的方式，它具有非常出色的使用体验，并且它可以在微信内被便捷地获取与传播。小程序发展史实际上，小程序并非凭空而来的。当微信逐渐流行、变成几乎人人都离不开的社交工具时，承载微信的 WebView 也逐渐成为了量级最大的移动 Web 入口。每天访问 WebView 的数量甚至超过了访问所有浏览器的总和。虽然无法通过第三方获取到微信 WebView 的日活数据，但这个客观事实间接促进了小程序的诞生。其实在小程序正式步入人们视线之前，微信早已有了类似的 js 调用接口，这里给大家展示一个调用了微信 js-bridge 原生组件去浏览图片的例子：WeixinJSBridge.invoke('imagePreview', {\r\ncurrent: 'http://inews.com',\r\nurls: [ // 所有图片的URL列表，数组格式\r\n    'https://img/1.jpg',\r\n    'https://img/2.jpg',\r\n    'https://img/3.jpg'\r\n]\r\n}, function(res) {\r\n    console.log(res.err_msg)\r\n})\r\n复制代码此类 js 接口其实最开始是专门给腾讯内部人员去进行调用的，但却意外被许多个人开发者发现很多并进行了使用，这也慢慢成为了微信中网页的标准。在 15 年开始的时候，微信官方发布了一套专门用于进行网页开发的工具包，名为 js-sdk ，在这个工具包内开放了如微信支付、录音、语音识别、等数十个接口。这给所有的 Web 开发者都打开了一扇从未开启过的全新的大门，让所有的开发者都可以自由地使用微信开发的原生能力，这使得他们可以去完成一些之前无法完成或是难以做到的事情。js-sdk 完美继承了 WeixinJSBridge 的特性，并且由只对内部开放转为了对外部开放。并且它通过其暴露的微信调用接口使得所有 Web 开发者有了更多操作微信功能的能力。但是，这个模式并没有很好地解决移动网页的体验问题：用户访问页面时，在页面显示前会有一段比较明显能够被感知的白屏过程。受限于网速与不同终端的性能，这个问题会越来越明显。于是乎，js-sdk 的增强版本就诞生了，其中有一个非常重要的新特性，被称之为： 微信 Web 资源离线存储 。​以下文字引用自内部的文档（没有最终对外开放）：微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。相信大家都已经看明白了，这其实就是 HTML5 中 Application Cache 的加强版。然而，在经过了多次测试后发现，还有问题没有被完全的解决：页面切换较为生硬；点击有明显延滞的感觉。最终微信意识到 js-sdk 无法处理这些问题，这需要一个全新的系统去完成，而这个系统必须具备以下几个能力：加载速度快原生的体验易用且安全的微信数据开放兼顾开发效率与开发难度而这就是小程序的由来。故事开始了前言首先请大家见谅，这一篇文章并不会教你如何零基础开发小程序。如果你是一个软件开发新手。那么我建议你先了解一些基础的 js 语法 以及相应的 前端知识 。掌握前端基础后，相信在 小程序前端组件官方文档 的帮助下，任何人都可以快速上手开发小程序。下面我主要跟大家分享两个最核心、 最省钱 的两个小程序开发技巧：搭建小程序云开发环境；如何使用云开发调用 AI 模型接口。小程序云开发在刚开始考虑开发小程序时，和你们一样，我有着许多的顾虑：需要购买域名、服务器吗？维护成本大吗？带着这些顾虑，我小心翼翼地翻开了 微信官方文档 。在大脑经过分布式阅读过后，我发现了 云开发 这个关键词。什么是云开发？微信官方文档中是这么解释的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。云开发提供了几大基础能力支持：简单来说，有了云开发， 我不需要购买服务器就可以开发一款全栈小程序。嘿嘿，没错，这就是我想要的。如何搭建小程序云开发环境那么如何搭建云开发环境呢，综合官方文档，我总结了一套极简搭建教程，大家可以作为参考。云开发环境极简搭建四部曲：首先，需要 注册一个小程序账号 ，添加管理员 / 开发者微信账号并记录下 APPID；接着需要下载 小程序开发工具 ；然后使用管理员 / 开发者账号登录开发工具并填入小程序的 APPID 以及勾选 云开发 选项后点击新建；点击页面中的云开发，跟着提示选择 免费版云开发配额 。至此一个云环境就算是搭建完毕了。什么是云函数？云开发环境搭建完毕后，是时候看看什么是 云函数 了。官方的定义如下：云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。简单来说，云函数就是运行在云端的函数。云函数有什么用？云函数大有用处。有了它，就相当于是有了一个 \"大后端\"，所有业务逻辑以及对数据库的操作我们都可以封装在云函数中调用，十分方便。第一个云函数说了这么多大道理，是时候来实战一下了。右键点击云函数环境 （cloudfunctions | xxxxxxx）后新建一个名为 test 的云函数：可以看到默认的文件（index.js）中已经有了云函数代码（获取当前微信用户上下文，并返回用户信息）：// 云函数入口文件\r\n\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n\r\nexports.main = async (event, context) => {\r\n\r\n\tconst wxContext = cloud.getWXContext()\r\n\r\n\treturn {\r\n\r\n\t\tevent,\r\n\t\t\r\n\t\topenid: wxContext.OPENID,\r\n\t\t\r\n\t\tappid: wxContext.APPID,\r\n\t\t\r\n\t\tunionid: wxContext.UNIONID,\r\n\t\r\n\t}\r\n\r\n}\r\n复制代码这时候需要开启命令行并进入到该目录下运行 npm install 安装 wx-server-sdk ( 若目录下没有 node_modules 则需要先运行 npm init )：最后右键点击该云函数并选择 开启云函数本地调试 后点击右下角调用：可以看到函数执行成功并拿到了返回值（openid 等信息......）至此，恭喜我们快速完成了第一个云函数。如何在小程序中快速调用 AI 模型来自清晨的灵光一闪相信大家都非常好奇，我是怎么做到在云函数中 \"零成本\" 调用 AI 能力的。其实我开始也非常苦恼这个问题，即使小程序有云函数的功能，但也没办法轻易 \"零成本\" 调用 AI 模型，原因如下：小程序云函数目前仅支持 node.js，而我的模型调用接口代码为 python；不管再怎么 \"云\"，想要运行自己的 AI 模型必须得有一台 16G 内存以上的机器（成本巨大）；即使有了自己的服务器也需要域名备案，实在是太麻烦了；但就在一个明媚的清晨，我翻身起床后突然灵光一闪：可不可以调用腾讯自己的 AI 开放接口间接达到这个目的呢？想法再多不如动手行动，于是我访问了 腾讯云控制台的自然语言处理模块 。根据指引进行服务开通后，我进入到 API 密钥管理 并记录下了 API 密钥：那么如何在小程序中调用它呢？我再一次陷入了深深的沉思......云函数调用 AI 模型在经过漫长的探索后我回到了 test 云函数目录下的命令行，安装了腾讯云服务调用包：npm install tencentcloud-sdk-nodejs\r\n复制代码然后修改 test 云函数 （index.js）：// 云函数入口文件\r\n\r\nconst cloud = require('wx-server-sdk')\r\n\r\nconst tencentcloud = require(\"tencentcloud-sdk-nodejs\");\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n\r\nexports.main = async (event, context) => {\r\n\r\n\tconst  NlpClient = tencentcloud.nlp.v20190408.Client;\r\n\t\r\n\tconst models = tencentcloud.nlp.v20190408.Models;\r\n\t\r\n\tconst  Credential = tencentcloud.common.Credential;\r\n\t\r\n\tconst  ClientProfile = tencentcloud.common.ClientProfile;\r\n\t\r\n\tconst  HttpProfile = tencentcloud.common.HttpProfile;\r\n\t\r\n\tlet cred = new  Credential(event.secretId, event.secretKey);\r\n\t\r\n\tlet httpProfile = new  HttpProfile();\r\n\t\r\n\thttpProfile.endpoint = \"nlp.tencentcloudapi.com\";\r\n\t\r\n\tlet clientProfile = new  ClientProfile();\r\n\t\r\n\tclientProfile.httpProfile = httpProfile;\r\n\t\r\n\tlet client = new  NlpClient(cred, \"ap-guangzhou\", clientProfile);\r\n\t\r\n\tlet req = new models.SentimentAnalysisRequest();\r\n\t\r\n\tlet text = event.text\r\n\t\r\n\tlet params = '{\"Text\":\\\"' + text + '\\\"}'\r\n\t\r\n\tconsole.log('待预测字符串： ' + text)\r\n\t\r\n\treq.from_json_string(params);\r\n\t\r\n\tclient.SentimentAnalysis(req, function (errMsg, response) {\r\n\t\r\n\t\tif (errMsg) {\r\n\t\t\r\n\t\tconsole.log(errMsg)\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\tconsole.log('AI 预测情绪正值: ' + response.Positive)\r\n\t\t\r\n\t\tconsole.log('AI 预测情绪负值: ' + response.Negative)\r\n\t\t\r\n\t})\r\n\r\n}\r\n复制代码在这段代码中，我通过腾讯云账号中的密钥连通了 AI 情感预测接口，最后将情感预测的结果打印了出来。接下来我开启了本地云函数调用窗口并传入相应参数：secretId （腾讯云 API 服务密钥 Id ）secretKey （腾讯云 API 服务密钥 Key）text （待预测的字符串）然后点击调用后终于看到了 AI 模型的预测结果：最后我成功地使用云函数调用了免费的 AI 开放接口。这时我已经热泪盈眶，除了感动还有一丝小满意，原来云开发还能这么玩。故事的结尾文章到这里，相信最重要的两个部分大家已经了解并掌握了：搭建云开发环境快速调用 AI 模型回头望去，整个小程序开发过程大概历经三天两夜，整段经历大概与 \"编程马拉松\" 类似。编程马拉松，又称黑客日、黑客节或编程节，是一个流传于黑客当中的新词汇。编程马拉松是一种活动。在该活动当中，计算机程序员以及其他与软件发展相关的人员，如图形设计师、界面设计师与项目经理，相聚在一起，以紧密合作的形式去进行某项软件项目。编程马拉松的灵魂是合作地编写程序和应用。编程马拉松的时长一般在几天到一周不等 。--维基百科于是乎，在经过 \"疯狂\" 开发后，一个日记小程序的雏形就诞生了。虽然说前端页面并没有多复杂，但是确实倾注了许多开发心血。开发完成的那一刻我已经不在乎是否有人真正去使用他。因为我已经从他身上收获到了全身心投入开发的快乐。最后，老铁，要不点个赞再走可好？么么哒1、给俺点个赞呗，可以让更多的人看到这篇文章，顺便激励下我，嘻嘻。2、老铁们，关注我的原创微信公众号「智能测试开发」，专注于写 AI 与测试开发的结合（AI + 测试 + 开发）。保证让你看完有所收获，不信你打我。后台回复『进阶教程』，免费送你一套关于测试与开发的进阶教程。作者简介作者：大家好，我是泰斯特，从测试入门，再转战开发，最后学习 AI。深知 AI 对测试与开发的影响力。，所以申请了一个微信公众号『智能测试开发』，泰斯特期待你的关注，和我一起学习。 转载说明：未获得授权，禁止转载最后预祝所有用心实践的读者都能开发出有特色的 AI 小程序~"}
